<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[柴魚筆記本]]></title><description><![CDATA[程式 • 軟體 • 攝影]]></description><link>http://localhost:2368/</link><image><url>http://localhost:2368/favicon.png</url><title>柴魚筆記本</title><link>http://localhost:2368/</link></image><generator>Ghost 3.1</generator><lastBuildDate>Tue, 01 Sep 2020 14:37:09 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[[Golang]使用筆畫排序中文字]]></title><description><![CDATA[有次嘗試要使用筆劃排序中文姓名時，直接使用sort包進行排序，但發現結果並不是照著筆劃排序，查了點資料發現原來和UTF-8、Big5兩種編碼有極大的關係]]></description><link>http://localhost:2368/golang-sort-traditionalchinese/</link><guid isPermaLink="false">5f4e5a4978355806f01eea76</guid><category><![CDATA[golang]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Tue, 01 Sep 2020 14:33:48 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/09/golang-long.jpeg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2020/09/golang-long.jpeg" alt="[Golang]使用筆畫排序中文字"><p>有次嘗試要使用筆劃排序中文姓名時，直接使用sort包進行排序，但發現結果並不是照著筆劃排序，查了點資料發現原來和UTF-8、Big5兩種編碼有極大的關係</p><h2 id="-">環境</h2><ul><li>Windows 10 x64</li><li>go 1.15</li><li>golang.org/x/text v0.3.3</li></ul><h2 id="utf-8-big5-">UTF-8和Big5的排序</h2><h3 id="big5">Big5</h3><p>從全字庫查詢到Big5的編碼原則</p><p>以國家標準CNS11643及國際標準ISO10646漢字集為字源範圍，並依CNS11643之序編碼。</p><p>而CNS11643的字碼編排原則又是如何呢?以下是定義</p><p>依<strong>先筆畫後部首</strong>排列順序編碼。 說明： 每一字面均以文字總筆畫數為首序、部首為次序、筆順為末序編訂字碼，使用者只需以書寫之實際筆畫數即可查尋到國標碼。</p><p>所以我們可以得知Big5以"<strong>筆畫-&gt;部首-&gt;筆順</strong>"為排列順序</p><h3 id="utf-8">UTF-8</h3><p>而全字庫裡對於UTF-8的說明如下</p><p>在I區的中日韓漢字部份，最當初進行編碼時，因各國漢字型體不盡相同，必須先進行認同(unify)整理工作，SC2/WG2因此邀集有關各國指派專家組成CJK/JRG(中日韓聯合研究工作組，即IRG前身)，進行字集的總整理。CJK/JRG歷經五次會議完成此項艱鉅工作，所整理的「中日韓認同表意文字」(CJK Unified Ideographs)參考了我國75年版CNS 11643之第1、2、14字面(T欄)，大陸的GB 2312、GB 12345、GB 7589、GB 17590、GB 8565(G欄)，日本的JIS X 0208、JIS X 0212(J欄)及南韓的KS C 5601、KSC 5667(K欄)等標準字符集，可說已包含這四地所常用的字。其字序主要是參考康熙字典、大漢和詞典、漢語大詞典及大字源字典，以<strong>先部首後筆劃</strong>的順序排列。</p><p>所以我們可以得知UTF-8以"<strong>部首-&gt;筆畫</strong>"為排列順序</p><h2 id="golang-">Golang的預設編碼</h2><p>golang預設使用UTF-8作為編碼格式，所以若直接使用sort包進行排序得出的結果會是依照先部首後筆畫的順序排序</p><h2 id="-big5-">轉為Big5排序</h2><p>若想得到以先筆畫後部首的方式排序，其中一個方法是將預設的UTF-8轉為Big5，使用Big5排序過後依照需求再轉換回UTF-8</p><h2 id="--1">程式碼</h2><p>以"<strong>毛隆青,劉雅君,陳嘉鴻,王育如,郭苡良,楊宗穎,李玉全,劉玉合,姚昶民,林欣麟</strong>"十個姓名作為測試資料輸入，結果應為[<strong>毛隆青 王育如 李玉全 林欣麟 姚昶民 郭苡良 陳嘉鴻 楊宗穎 劉玉合 劉雅君</strong>]</p><p>此處須注意若筆劃數量相同，則會比對完部首後再比對下一個字，例如:<br><strong>毛隆青</strong>和<strong>王育如</strong>姓氏都是四劃，但是比對過筆劃後結果是'<strong>毛</strong>'先於'<strong>王</strong>'所以'<strong>毛</strong>'才會排在'<strong>王</strong>'前面</p><p><strong>main.go</strong></p><pre><code class="language-go">package main

import (
	"fmt"
	"sort"

	"golang.org/x/text/encoding/traditionalchinese"
	"golang.org/x/text/transform"
)

func main() {

	s := []string{"毛隆青", "劉雅君", "陳嘉鴻", "王育如", "郭苡良", "楊宗穎", "李玉全", "劉玉合", "姚昶民", "林欣麟"}

	s1 := sortByStroke(s)
	fmt.Println(s1)
}

func sortByStroke(input []string) (output []string) {
	output = make([]string, 0)
    
	//建立Encoder和Decoder
	utf8ToBig5 := traditionalchinese.Big5.NewEncoder()
	big5ToUtf8 := traditionalchinese.Big5.NewDecoder()

	//將UTF-8轉換為Big5
	for index := range input {
		big5, _, _ := transform.String(utf8ToBig5, input[index])
		input[index] = big5
	}

	//使用轉換成Big5的編碼進行排序
	sort.Strings(input)

	//將排序過後的Big5碼轉回UTF-8並放入output slice
	for _, value := range input {
		utf8, _, _ := transform.String(big5ToUtf8, value)
		output = append(output, utf8)
	}

	return output
}
</code></pre><pre><code>D:\&gt;go run main
[毛隆青 王育如 李玉全 林欣麟 姚昶民 郭苡良 陳嘉鴻 楊宗穎 劉玉合 劉雅君]
</code></pre><h2 id="--2">參考資料</h2><p><a href="https://www.cns11643.gov.tw/pageView.jsp?ID=9">全字庫-中文碼介紹</a></p>]]></content:encoded></item><item><title><![CDATA[[GolangPackage] 使用lnx/walk建立圖形化介面]]></title><description><![CDATA[golang 普遍使用CLI作為使用者介面，但因為需要做一個程式給不常使用指令的人使用，所以使用lxn/walk建立圖形化使用者介面，lxn/walk可以滿足視窗的大部分需求，適用於建立一些基本的圖形化介面]]></description><link>http://localhost:2368/golang-package-walk/</link><guid isPermaLink="false">5f4809f66c8c391358537596</guid><category><![CDATA[golang]]></category><category><![CDATA[golangPackage]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Thu, 27 Aug 2020 19:48:31 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/08/golang-long.jpeg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2020/08/golang-long.jpeg" alt="[GolangPackage] 使用lnx/walk建立圖形化介面"><p>golang 普遍使用CLI作為使用者介面，但因為需要做一個程式給不常使用指令的人使用，所以使用lxn/walk建立圖形化使用者介面，lxn/walk可以滿足視窗的大部分需求，適用於建立一些基本的圖形化介面</p><h2 id="-">環境</h2><ul><li>Windows 10 x64</li><li>go 1.15</li><li>github.com/lxn/walk v0.0.0-20200806153934-8721e9bc9ff7</li><li>github.com/akavel/rsrc v0.9.0</li></ul><h2 id="--1">安裝</h2><p>要將程式包裝成可執行檔需要兩個package，分別是lxn/walk和akavel/rsrc<br>lxn/walk用來建立圖形化介面<br>akavel/rsrc用來將資源嵌入可執行檔<br>使用指令安裝lxn/walk和akavel/rsrc</p><pre><code>go get github.com/lxn/walk
go get github.com/akavel/rsrc
</code></pre><h2 id="--2">結構</h2><p>在lxn/walk下包含了declarative sub package、範例檔和各種元件的檔案</p><pre><code>－github.com
    |－lxn
        |－walk
            |－declarative
            |－examples
            |...其他檔案
</code></pre><p>以examples下的action範例裡的一小段程式碼為例</p><pre><code>PushButton{
	AssignTo: &amp;toggleSpecialModePB,
	Text:     "Enable Special Mode",
	OnClicked: func() {
		isSpecialMode.SetSatisfied(!isSpecialMode.Satisfied())

		if isSpecialMode.Satisfied() {
			toggleSpecialModePB.SetText("Disable Special Mode")
		} else {
			toggleSpecialModePB.SetText("Enable Special Mode")
		}
	},
	Accessibility: Accessibility{
		Help: "Toggles special mode",
	},
},
</code></pre><p>很好奇PushButton裡面的這些參數到底是哪裡來的對吧<br>讓我們看看declarative目錄下的pushbutton.go檔案</p><p><strong>pushbutton.go</strong></p><pre><code>package declarative

import (
	"github.com/lxn/walk"
)

type PushButton struct {
	// Window

	Accessibility      Accessibility
	Background         Brush
	ContextMenuItems   []MenuItem
	DoubleBuffering    bool
	Enabled            Property
	Font               Font
	MaxSize            Size
	MinSize            Size
	Name               string
	OnBoundsChanged    walk.EventHandler
	OnKeyDown          walk.KeyEventHandler
	OnKeyPress         walk.KeyEventHandler
	OnKeyUp            walk.KeyEventHandler
	OnMouseDown        walk.MouseEventHandler
	OnMouseMove        walk.MouseEventHandler
	OnMouseUp          walk.MouseEventHandler
	OnSizeChanged      walk.EventHandler
	Persistent         bool
	RightToLeftReading bool
	ToolTipText        Property
	Visible            Property

	// Widget

	Alignment          Alignment2D
	AlwaysConsumeSpace bool
	Column             int
	ColumnSpan         int
	GraphicsEffects    []walk.WidgetGraphicsEffect
	Row                int
	RowSpan            int
	StretchFactor      int

	// Button

	Image     Property
	OnClicked walk.EventHandler
	Text      Property

	// PushButton

	AssignTo       **walk.PushButton
	ImageAboveText bool
}
</code></pre><p>這邊清楚的定義了哪些元件可以用哪些參數，只要照著結構裡定義的屬性名稱和型別給予對應的數值就可以了</p><h2 id="--3">建置與執行</h2><p>要執行圖形化介面無法直接使用go run執行<br>必須在相同目錄下新增.manifest檔案並使用go build建置產生可執行檔<br>再啟動可執行檔執行<br>我們使用examples下的clipboard作為範例</p><p><strong>clipboard.go</strong></p><pre><code>// Copyright 2013 The Walk Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"log"
)

import (
	"github.com/lxn/walk"
	. "github.com/lxn/walk/declarative"
)

func main() {
	var te *walk.TextEdit

	if _, err := (MainWindow{
		Title:   "Walk Clipboard Example",
		MinSize: Size{300, 200},
		Layout:  VBox{},
		Children: []Widget{
			PushButton{
				Text: "Copy",
				OnClicked: func() {
					if err := walk.Clipboard().SetText(te.Text()); err != nil {
						log.Print("Copy: ", err)
					}
				},
			},
			PushButton{
				Text: "Paste",
				OnClicked: func() {
					if text, err := walk.Clipboard().Text(); err != nil {
						log.Print("Paste: ", err)
					} else {
						te.SetText(text)
					}
				},
			},
			TextEdit{
				AssignTo: &amp;te,
			},
		},
	}).Run(); err != nil {
		log.Fatal(err)
	}
}
</code></pre><p><strong>test.manifest</strong></p><pre><code>&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0"&gt;
    &lt;assemblyIdentity version="1.0.0.0" processorArchitecture="*" name="SomeFunkyNameHere" type="win32"/&gt;
    &lt;dependency&gt;
        &lt;dependentAssembly&gt;
            &lt;assemblyIdentity type="win32" name="Microsoft.Windows.Common-Controls" version="6.0.0.0" processorArchitecture="*" publicKeyToken="6595b64144ccf1df" language="*"/&gt;
        &lt;/dependentAssembly&gt;
    &lt;/dependency&gt;
    &lt;application xmlns="urn:schemas-microsoft-com:asm.v3"&gt;
        &lt;windowsSettings&gt;
            &lt;dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings"&gt;PerMonitorV2, PerMonitor&lt;/dpiAwareness&gt;
            &lt;dpiAware xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings"&gt;True&lt;/dpiAware&gt;
        &lt;/windowsSettings&gt;
    &lt;/application&gt;
&lt;/assembly&gt;
</code></pre><p>建立一個目錄並在目錄底下放置clipboard.go和test.manifest兩個檔案</p><pre><code>－walktest
    |－clipboard.go
    |－test.manifest
</code></pre><p>第一次要使用指令產生.syso檔</p><pre><code>rsrc -manifest test.manifest -o rsrc.syso
</code></pre><p>再輸入指令建置可執行檔</p><pre><code>go build
</code></pre><p>運行可執行檔就會出現圖形化介面了</p><pre><code>walktest.exe
</code></pre><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2020/08/1.png" class="kg-image" alt="[GolangPackage] 使用lnx/walk建立圖形化介面"></figure>]]></content:encoded></item><item><title><![CDATA[Qt的鍵盤與滑鼠點擊事件]]></title><description><![CDATA[Qt的鍵盤與滑鼠點擊事件]]></description><link>http://localhost:2368/qt-key-mouse-press-event/</link><guid isPermaLink="false">5ee33b6118d9a726c4d13dcf</guid><category><![CDATA[Qt]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Fri, 12 Jun 2020 14:29:28 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/06/DarkCyan.jpg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2020/06/DarkCyan.jpg" alt="Qt的鍵盤與滑鼠點擊事件"><p></p><h2 id="-">環境</h2><p>Qt 5.14.1<br>Qt Creator 4.11.1</p><hr><h2 id="--1">滑鼠點擊事件</h2><p>引用QMouseEvent標頭檔</p><!--kg-card-begin: markdown--><pre><code>#include &lt;QMouseEvent&gt;</code></pre>
<!--kg-card-end: markdown--><p>在protected裡定義滑鼠觸發事件</p><!--kg-card-begin: markdown--><pre><code>protected:
    void mousePressEvent(QMouseEvent * event);</code></pre>
<!--kg-card-end: markdown--><p>新增具體觸發事件</p><!--kg-card-begin: markdown--><pre><code>void MainWindow::mousePressEvent(QMouseEvent * e)
{
    //獲取座標
    qDebug() &lt;&lt;&quot;(&quot;&lt;&lt; e-&gt;x() &lt;&lt; &quot;,&quot; &lt;&lt; e-&gt;y()&lt;&lt;&quot;)&quot;;

    if(e-&gt;button() == Qt::LeftButton)
    {
        qDebug() &lt;&lt; &quot;左鍵&quot; ;
    }
    else if(e-&gt;button() == Qt::RightButton)
    {
        qDebug() &lt;&lt; &quot;右鍵&quot; ;
    }
}</code></pre>
<!--kg-card-end: markdown--><p>要使用qDebug()輸出時必須增加#include&lt;QDebug&gt;引用QDebug標頭檔</p><hr><h2 id="--2">鍵盤點擊事件</h2><p>在protected裡定義滑鼠觸發事件</p><!--kg-card-begin: markdown--><pre><code>protected:
    void keyPressEvent(QKeyEvent * event);</code></pre>
<!--kg-card-end: markdown--><p>新增鍵盤觸發事件</p><!--kg-card-begin: markdown--><pre><code>void MainWindow::keyPressEvent(QKeyEvent * event)
{
    switch (event-&gt;key())
    {
        case Qt::Key_Alt:{
                qDebug() &lt;&lt; &quot;Alt&quot;;
            break;
        }
        default:{
                qDebug() &lt;&lt; event-&gt;key();
            break;
        }
    }
}</code></pre>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[GolangPackage 指定golang執行檔檔案屬性]]></title><description><![CDATA[GoVersionInfo package可在生成執行檔時指定執行檔縮圖及檔案屬性，檔案描述、檔案類型、版本等參數皆可指定]]></description><link>http://localhost:2368/golang-package-goversioninfo/</link><guid isPermaLink="false">5ec6a6b6986e6527cc1d24c9</guid><category><![CDATA[golangPackage]]></category><category><![CDATA[golang]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Thu, 21 May 2020 17:34:18 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/05/golang-long.jpeg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2020/05/golang-long.jpeg" alt="GolangPackage 指定golang執行檔檔案屬性"><p>GoVersionInfo package可在生成執行檔時指定執行檔縮圖及檔案屬性，檔案描述、檔案類型、版本等參數皆可指定</p><hr><h2 id="-">安裝<br></h2><h3 id="-package">使用指令安裝package</h3><!--kg-card-begin: markdown--><pre><code>go get github.com/josephspurrier/goversioninfo/cmd/goversioninfo</code></pre>
<!--kg-card-end: markdown--><h3 id="--1">產生可執行檔</h3><p>-0 bin/goversioninfo.exe代表要將產生出來的可執行檔放在bin目錄裡，並將檔名命名為goversioninfo.exe<br>空一格後面接github.com/josephspurrier/goversioninfo/cmd/goversioninfo代表要以這個package為目標產生可執行檔</p><!--kg-card-begin: markdown--><pre><code>go build -o bin/goversioninfo.exe github.com/josephspurrier/goversioninfo/cmd/goversioninfo</code></pre>
<!--kg-card-end: markdown--><hr><h2 id="--2">設定<br></h2><h3 id="-go-generate-">設定go generate註釋</h3><p>將//go:generate goversioninfo加入到程式碼的最頂端，往後在執行go generate命令時才能夠被搜尋到</p><!--kg-card-begin: markdown--><pre><code>//go:generate goversioninfo

package main

import &quot;fmt&quot;

func main() {
    fmt.Println(&quot;Hello world&quot;)
}
</code></pre>
<!--kg-card-end: markdown--><h3 id="-versioninfo-json-">設定versioninfo.json檔案</h3><p>在github.com\josephspurrier\goversioninfo\testdata\resource內有一個檔名為versioninfo的json檔，將其複製並放置於要產生執行檔的程式碼的目錄中</p><p>resource資料夾內有icon和goversioninfo.exe.manifest兩個檔案，等等在設定versioninfo時會用到</p><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2020/05/---2020-05-22-012503.png" class="kg-image" alt="GolangPackage 指定golang執行檔檔案屬性"></figure><h3 id="-versioninfo-json--1">指定versioninfo.json檔案參數</h3><p>將IconPath和ManifestPath的路徑指定為可執行檔圖示的路徑和Manifest檔案的路徑</p><!--kg-card-begin: markdown--><pre><code>{
    &quot;FixedFileInfo&quot;: {
        &quot;FileVersion&quot;: {
            &quot;Major&quot;: 1,
            &quot;Minor&quot;: 0,
            &quot;Patch&quot;: 0,
            &quot;Build&quot;: 0
        },
        &quot;ProductVersion&quot;: {
            &quot;Major&quot;: 1,
            &quot;Minor&quot;: 0,
            &quot;Patch&quot;: 0,
            &quot;Build&quot;: 0
        },
        &quot;FileFlagsMask&quot;: &quot;3f&quot;,
        &quot;FileFlags &quot;: &quot;00&quot;,
        &quot;FileOS&quot;: &quot;040004&quot;,
        &quot;FileType&quot;: &quot;01&quot;,
        &quot;FileSubType&quot;: &quot;00&quot;
    },
    &quot;StringFileInfo&quot;: {
        &quot;Comments&quot;: &quot;Test file.&quot;,
        &quot;CompanyName&quot;: &quot;josephspurrier&quot;,
        &quot;FileDescription&quot;: &quot;This is a hello world file.&quot;,
        &quot;FileVersion&quot;: &quot;v1.0.0.0&quot;,
        &quot;InternalName&quot;: &quot;goversioninfo.exe&quot;,
        &quot;LegalCopyright&quot;: &quot;Copyright (c) 2019 Joseph Spurrier&quot;,
        &quot;LegalTrademarks&quot;: &quot;&quot;,
        &quot;OriginalFilename&quot;: &quot;main.go&quot;,
        &quot;PrivateBuild&quot;: &quot;&quot;,
        &quot;ProductName&quot;: &quot;goversioninfo&quot;,
        &quot;ProductVersion&quot;: &quot;v1.0.0.0&quot;,
        &quot;SpecialBuild&quot;: &quot;&quot;
    },
    &quot;VarFileInfo&quot;: {
        &quot;Translation&quot;: {
            &quot;LangID&quot;: &quot;0409&quot;,
            &quot;CharsetID&quot;: &quot;04B0&quot;
        }
    },
    &quot;IconPath&quot;: &quot;resource/icon.ico&quot;,
    &quot;ManifestPath&quot;: &quot;resource/goversioninfo.exe.manifest&quot;
}</code></pre>
<!--kg-card-end: markdown--><h3 id="-syso-">產生syso檔</h3><p>輸入go generate指令產生resource.syso檔案，若不在同個目錄內可指定package路徑，例如主程式在D:\Project\Go\src\goinfotest，若當前位置在目錄內直接下go generate即可，若不在目錄內則要輸入go generate+從src目錄後開始算的package路徑(go generate goinfotest)產生syso檔</p><!--kg-card-begin: markdown--><pre><code>go generate
go generate your\package\route</code></pre>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2020/05/---2020-05-22-013035.png" class="kg-image" alt="GolangPackage 指定golang執行檔檔案屬性"></figure><h3 id="--3">產生可執行檔</h3><p>使用go build產生可執行檔，亦可使用"go build -o 目的路徑與檔名 +package路徑"產生可執行檔</p><!--kg-card-begin: markdown--><pre><code>go build
go build -o output\route your\package\route</code></pre>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2020/05/---2020-05-22-013343.png" class="kg-image" alt="GolangPackage 指定golang執行檔檔案屬性"></figure>]]></content:encoded></item><item><title><![CDATA[C++陣列與指標的位址]]></title><description><![CDATA[C++陣列與指標的位址]]></description><link>http://localhost:2368/cpp-array-pointer-address/</link><guid isPermaLink="false">5e71c4046286de0ce0c06f09</guid><category><![CDATA[C++]]></category><category><![CDATA[C++Basic]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Wed, 18 Mar 2020 07:43:05 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/03/C--.jpg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2020/03/C--.jpg" alt="C++陣列與指標的位址"><p>首先宣告名稱為arr大小為10的int陣列，接著分別輸出arr、&amp;arr[0]和&amp;arr</p><!--kg-card-begin: markdown--><pre><code>#include &lt;iostream&gt;

int main()
{
    int arr[10] = { 0 };

    std::cout &lt;&lt; &quot;arr\t&quot; &lt;&lt; arr &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;&amp;arr[0]\t&quot; &lt;&lt; &amp;arr[0] &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;&amp;arr\t&quot; &lt;&lt; &amp;arr &lt;&lt; std::endl;
}</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>&gt;arr     006FFC80
&gt;&amp;arr[0] 006FFC80
&gt;&amp;arr    006FFC80</code></pre>
<!--kg-card-end: markdown--><p>我們可以看到直接輸出陣列變數時會出現陣列中第一個元素的位址</p><p>輸出&amp;arr[0]也會出現陣列中第一個元素的位址，其中arr[0]代表第零個元素，而將&amp;加在前面則代表取得其位址，也就是arr[0]的位址</p><p>2而&amp;arr代表輸出arr變數位址，其位址就是第零個元素的位址，也就等於arr[0]的位址，所以輸出的結果會與前兩個相同</p><p></p><p>這時我們宣告一個名稱為p的int指標，將arr的位址指派給它，並分別輸出p、&amp;p[0]和&amp;p</p><!--kg-card-begin: markdown--><pre><code>#include &lt;iostream&gt;

int main()
{
    int arr[10] = { 0 };

    std::cout &lt;&lt; &quot;arr\t&quot; &lt;&lt; arr &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;&amp;arr[0]\t&quot; &lt;&lt; &amp;arr[0] &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;&amp;arr\t&quot; &lt;&lt; &amp;arr &lt;&lt; std::endl;

    int* p = arr;
    std::cout &lt;&lt; &quot;p\t&quot; &lt;&lt; p &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;&amp;p[0]\t&quot; &lt;&lt; &amp;p[0] &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;&amp;p\t&quot; &lt;&lt; &amp;p &lt;&lt; std::endl;
}</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>&gt;p       006FFC80
&gt;&amp;p[0]   006FFC80
&gt;&amp;p      006FFC74</code></pre>
<!--kg-card-end: markdown--><p>這時p指標中儲存的是arr的位址，所以輸出的自然也就和arr的位址相同</p><p>&amp;p[0]指的是p[0]這個元素的位址，因為p指標是指向arr陣列的，所以當存取p[0]時會去尋找arr[0]，而自然其位址也就會等於arr[0]的位址</p><p>比較特別的是&amp;p，&amp;p代表取得p的位址，而因為p是指標，我們是取得p的位址，所以和arr的位址就不會是同一個了</p>]]></content:encoded></item><item><title><![CDATA[開啟Clover時顯示錯誤訊息：Cannot install without ensuring the file system is read-write]]></title><description><![CDATA[在開啟Clover時會跳出"Cannot install without ensuring the file system is read-write"錯誤訊息]]></description><link>http://localhost:2368/clover-package-err/</link><guid isPermaLink="false">5e512e2257c9b119c4cb7261</guid><category><![CDATA[clover]]></category><category><![CDATA[hackintosh]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Sat, 22 Feb 2020 14:11:49 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/02/clover-1.png" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2020/02/errMsg.png" class="kg-image" alt="開啟Clover時顯示錯誤訊息：Cannot install without ensuring the file system is read-write"></figure><img src="http://localhost:2368/content/images/2020/02/clover-1.png" alt="開啟Clover時顯示錯誤訊息：Cannot install without ensuring the file system is read-write"><p></p><h2 id="-">版本</h2><p>OS：macOs Catalina  Version 10.15.3<br>Clover：Clover_v2.5k_r5104</p><hr><h2 id="--1">問題</h2><p>在開啟Clover時會跳出"Cannot install without ensuring the file system is read-write"錯誤訊息</p><hr><h2 id="--2">解決方法及步驟</h2><p>1.Click the Apple symbol in the Menu bar.<br>2.Click Restart…<br>3.Hold down Command-R to reboot into Recovery Mode.<br>4.Click Utilities.<br>5.Select Terminal.<br>6.Type csrutil disable.<br>7.Press Return or Enter on your keyboard.<br>8.Click the Apple symbol in the Menu bar.<br>9.Click Restart…</p><hr><h2 id="--3">參考資料</h2><figure class="kg-card kg-embed-card">
    <blockquote class="reddit-card">
      <a href="https://www.reddit.com/r/hackintosh/comments/d9pbhy/clover_cannot_install_wo_ensuring_file_system_is/?ref_source=embed&amp;ref=share">Clover - Cannot Install w/o Ensuring File System is Read/Write</a> from
      <a href="https://www.reddit.com/r/hackintosh/">hackintosh</a>
    </blockquote>
    <script async src="https://embed.redditmedia.com/widgets/platform.js" charset="UTF-8"></script>
</figure>]]></content:encoded></item><item><title><![CDATA[Golang channel簡介]]></title><description><![CDATA[在golang裡可使用channel在多個執行緒與主程式之間傳送資料，channel可設定不同型態的buffer，並指定緩衝區大小]]></description><link>http://localhost:2368/golang-channel/</link><guid isPermaLink="false">5e2ee3d2c847230f10934c35</guid><category><![CDATA[golang]]></category><category><![CDATA[golangBasic]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Mon, 27 Jan 2020 15:43:32 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/01/golang-long-2.jpeg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2020/01/golang-long-2.jpeg" alt="Golang channel簡介"><p></p><p>在golang裡可使用channel在多個執行緒與主程式之間傳送資料，channel可設定不同型態的buffer，並指定緩衝區大小</p><hr><h2 id="-channel">建立channel</h2><p>使用make配置空間，第一個參數使用chan指定為通道類型，後面接上channel的型態，第二個參數可加可不加，用來宣告buffer的大小</p><!--kg-card-begin: markdown--><pre><code>ch := make(chan int)
ch := make(chan int,5)</code></pre>
<!--kg-card-end: markdown--><p>須注意buffer的預設大小為零，若無指定buffer大小則發送方與接收方需同時準備好才可傳值，否則會造成deadlock(死結)</p><!--kg-card-begin: markdown--><pre><code>//OK(buffer為0)
ch := make(chan int)
defer close(ch)
go func(){
    ch &lt;- 7
}()

fmt.Println(&lt;-ch)

//ERROR(buffer為0)
ch := make(chan int)
defer close(ch)
ch &lt;- 7

fmt.Println(&lt;-ch)

//OK(buffer為1)
ch := make(chan int,1)
defer close(ch)
ch &lt;- 7

fmt.Println(&lt;-ch)</code></pre>
<!--kg-card-end: markdown--><hr><h2 id="-channel-">使用channel傳遞數值</h2><h3 id="-channel-1">傳入channel</h3><p>將箭頭由數值指向channel，代表將值傳入到channel內</p><!--kg-card-begin: markdown--><pre><code>ch &lt;- 7</code></pre>
<!--kg-card-end: markdown--><h3 id="-channel-2">傳出channel</h3><p>將箭頭由channel指向目的地，代表將數值由channel傳出</p><!--kg-card-begin: markdown--><pre><code>var result int
result &lt;- ch
fmt.Println(result)</code></pre>
<!--kg-card-end: markdown--><hr><h2 id="-goroutine-">等待所有goroutine結束</h2><p>有時會遇到明明寫好了goroutine，但在最後將要把數據輸出時卻沒出現任何數據，這時就有可能是因為執行緒尚未結束運算而主程式已經執行完輸出的作業了，所以輸出時不會得到channel傳來的任何資訊，當然也不會輸出任何東西</p><!--kg-card-begin: markdown--><pre><code>func foo(ch chan int, val int) {
    ch &lt;- val
}

func main() {
    ch := make(chan int, 5)
    for i := 0; i &lt; 5; i++ {
        foo(ch, i)
    }
    close(ch)

    for ele := range ch {
        fmt.Println(ele)
    }
}</code></pre>
<!--kg-card-end: markdown--><p>我們可以使用WaitGroup控制，等到所有執行緒都結束後再繼續往下執行</p><!--kg-card-begin: markdown--><pre><code>var wg sync.WaitGroup

func foo(ch chan int, val int) {
    defer wg.Done()
    ch &lt;- val
}

func main() {
    ch := make(chan int, 5)
    for i := 0; i &lt; 5; i++ {
        wg.Add(1)
        foo(ch, i)
    }
    wg.Wait()
    close(ch)

    for ele := range ch {
        fmt.Println(ele)
    }
}</code></pre>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[GolangPackage Excel的讀寫與操作]]></title><description><![CDATA[excelize是一個能夠讀寫excel的package，可讀入或寫入指定位置的資料及更改樣式，適用於批量產生excel檔案及資料處理]]></description><link>http://localhost:2368/golang-package-excelize/</link><guid isPermaLink="false">5e2d660c17169e27181beddf</guid><category><![CDATA[golang]]></category><category><![CDATA[golangPackage]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Sun, 26 Jan 2020 15:50:18 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/01/golang-long-1.jpeg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2020/01/golang-long-1.jpeg" alt="GolangPackage Excel的讀寫與操作"><p></p><p>excelize是一個能夠讀寫excel的package，可讀入或寫入指定位置的資料及更改樣式，適用於批量產生excel檔案及資料處理，須注意的是該package只支援.xlsx的檔案格式，尚不支援.xls的檔案處理</p><hr><h2 id="-">安裝</h2><p>使用指令安裝package</p><!--kg-card-begin: markdown--><pre><code>go get github.com/Luxurioust/excelize</code></pre>
<!--kg-card-end: markdown--><hr><h2 id="--1">檔案操作<br></h2><h3 id="--2">創建新檔</h3><!--kg-card-begin: markdown--><pre><code>xlsx := excelize.NewFile()</code></pre>
<!--kg-card-end: markdown--><h3 id="--3">開啟舊檔</h3><!--kg-card-begin: markdown--><pre><code>inputFilePath := &quot;D:\Project&quot;
xlsx, err := excelize.OpenFile(inputFilePath)
if err != nil {
	fmt.Println(&quot;\rERROR:&quot;, err)
}</code></pre>
<!--kg-card-end: markdown--><h3 id="--4">讀取內容</h3><p>將檔案內的資料讀入一個二維的字串slice</p><!--kg-card-begin: markdown--><pre><code>sheetName := &quot;Sheet1&quot;//指定要讀取的工作表名稱
xlsxRows, err = xlsx.GetRows(sheetName)
if err != nil {
	fmt.Println(&quot;\rERROR:&quot;,err)
}</code></pre>
<!--kg-card-end: markdown--><h3 id="--5">變更工作表名稱</h3><!--kg-card-begin: markdown--><pre><code>oldSheetName := &quot;Sheet1&quot;//指定目前工作表名稱
newSheetName := &quot;工作表&quot;//指定新的工作表名稱
xlsx.SetSheetName(oldSheetName, newSheetName)</code></pre>
<!--kg-card-end: markdown--><h3 id="--6">設定樣式</h3><p><strong>建立樣式</strong><br>呼叫函式時使用JSON格式填入所需的樣式參數</p><p>fill：設定儲存格網底</p><!--kg-card-begin: markdown--><table>
<thead>
<tr>
<th>fill</th>
<th>使用單一顏色填充</th>
<th>使用漸層填充</th>
</tr>
</thead>
<tbody>
<tr>
<td>typr</td>
<td>pattern</td>
<td>gradient</td>
</tr>
<tr>
<td>color</td>
<td>[&quot;#FFFFFF&quot;]</td>
<td>[&quot;#FFFFFF&quot;,&quot;#E0EBF5&quot;]</td>
</tr>
<tr>
<td>gradient</td>
<td>X</td>
<td>0:橫向<br>1:縱向<br>2:對角線向上<br>3:對角線向下<br>4:由對角線向內<br>5:由中心向外</td>
</tr>
<tr>
<td>pattern</td>
<td>0:無<br>1:實心<br>2:75%灰色<br>3:50%灰色<br>4:25%灰色<br>5:水平條紋<br>6:垂直條紋<br>7:反對角線條紋<br>8:對角線條紋<br>9:對角線斜紋<br>10:粗線對角線斜紋<br>11:細線水平條紋<br>12:細線垂直條紋<br>13:細線反對角線條紋<br>14:細線對角線條紋<br>15:細線水平斜紋<br>16:細線對角線斜紋<br>17:12.5%灰色<br>18:6.25%灰色</td>
<td>X</td>
</tr>
</tbody>
</table>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>//單一顏色填充
patternStyle, err := xlsx.NewStyle(`{&quot;fill&quot;:{&quot;type&quot;:&quot;pattern&quot;,&quot;color&quot;:[&quot;#EBF0F3&quot;],&quot;pattern&quot;:1}}`)
if err != nil {
	fmt.Println(&quot;\rERROR:&quot;,err)
}

//漸層填充
gradientStyle, err := f.NewStyle(`{&quot;fill&quot;:{&quot;type&quot;:&quot;gradient&quot;,&quot;color&quot;:[&quot;#FFFFFF&quot;,&quot;#E0EBF5&quot;],&quot;shading&quot;:1}}`)
if err != nil {
    fmt.Println(err)
}
</code></pre>
<!--kg-card-end: markdown--><p></p><p>font：設定儲存格字體</p><!--kg-card-begin: markdown--><table>
<thead>
<tr>
<th style="text-align:center">font</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">bold</td>
<td style="text-align:center">true/false</td>
</tr>
<tr>
<td style="text-align:center">italic</td>
<td style="text-align:center">true/false</td>
</tr>
<tr>
<td style="text-align:center">family</td>
<td style="text-align:center">字型名稱</td>
</tr>
<tr>
<td style="text-align:center">size</td>
<td style="text-align:center">字體大小</td>
</tr>
<tr>
<td style="text-align:center">color</td>
<td style="text-align:center">[&quot;#FFFFFF&quot;]</td>
</tr>
</tbody>
</table>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>fontStyle, err := f.NewStyle(`{&quot;font&quot;:{&quot;bold&quot;:true,&quot;italic&quot;:false,&quot;size&quot;:12,&quot;color&quot;:&quot;#FFFFFF&quot;}}`)
if err != nil {
    fmt.Println(err)
}</code></pre>
<!--kg-card-end: markdown--><p><strong>使用樣式</strong></p><!--kg-card-begin: markdown--><pre><code>//使用樣式設定column
err := xlsx.SetColStyle(sheetName, &quot;A1&quot;, patternStyle)

//使用樣式設定cell
err := xlsx.SetCellStyle(sheetName, &quot;A1&quot;, &quot;A1&quot;, gradientStyle)</code></pre>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[記憶體的時脈與頻寬]]></title><description><![CDATA[記憶體的時脈與頻寬]]></description><link>http://localhost:2368/clock-and-bandwidth/</link><guid isPermaLink="false">5e1de4127108022a40ad7b02</guid><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Tue, 14 Jan 2020 16:21:42 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/01/binary-code-binary-binary-system-byte-bits-administrator-1458897-pxhere.com.jpg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2020/01/binary-code-binary-binary-system-byte-bits-administrator-1458897-pxhere.com.jpg" alt="記憶體的時脈與頻寬"><p></p><h2 id="-">傳輸寬度</h2><h3 id="--1">每次可傳輸的量</h3><p>資料進出記憶體時會有寬度的限制，若頻寬是8bit，則代表一次可進去8個bit，若是64bit，則代表一次可同時傳輸64bit</p><hr><h2 id="--2">時脈</h2><h3 id="--3">一秒可傳輸多少次</h3><p>以Hz作為單位，代表一秒可以傳多少次，例如800MHz則為每秒800百萬次</p><hr><h2 id="--4">頻寬</h2><h3 id="--5">一秒可傳輸的量</h3><p>一秒可傳輸多少次 * 每次可傳輸的量 = 一秒可傳輸的量，以寬度為64bit及時脈為800HHz的例子來說，記憶體頻寬即為每秒64GB</p><p>64bit * 800MHz = 8Bytes * 800MHz = 6400 MBHz = 6.4GBHz = 每秒64GB</p>]]></content:encoded></item><item><title><![CDATA[使用Python爬蟲抓取網站資料]]></title><description><![CDATA[使用python抓取網站或網頁資料是再方便不過的了，常見的抓取方法包含抓取網站回應的JSON檔，或是直接抓取網頁內容並進行分析，以下紀錄兩種方法該如何實作。]]></description><link>http://localhost:2368/python-web-crawler/</link><guid isPermaLink="false">5e0e8ba22418ef16205128e7</guid><category><![CDATA[python]]></category><category><![CDATA[crawler]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Fri, 03 Jan 2020 16:48:36 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/01/python-logo.jpg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2020/01/python-logo.jpg" alt="使用Python爬蟲抓取網站資料"><p></p><p>使用python抓取網站或網頁資料是再方便不過的了，常見的抓取方法包含抓取網站回應的JSON檔，或是直接抓取網頁內容並進行分析，以下紀錄兩種方法該如何實作。</p><hr><h2 id="-">建立請求<br></h2><p>載入requests模組以建立HTTP請求</p><!--kg-card-begin: markdown--><pre><code>import requests</code></pre>
<!--kg-card-end: markdown--><p>建立GET請求</p><!--kg-card-begin: markdown--><pre><code>url = '' //填入目標網址以取得網頁內容
resp = requests.get(url) //建立get請求</code></pre>
<!--kg-card-end: markdown--><hr><h2 id="--1">解析請求<br></h2><h3 id="-json">目標為JSON</h3><p>使用<strong>json()</strong>方法解析內容，返回值(data)為字典</p><!--kg-card-begin: markdown--><pre><code>data = resp.json()</code></pre>
<!--kg-card-end: markdown--><h3 id="-html-">目標為HTML網頁內容</h3><p>需使用BeautifulSoup模組裡的方法，使用以下指令載入該模組</p><!--kg-card-begin: markdown--><pre><code>from bs4 import BeautifulSoup</code></pre>
<!--kg-card-end: markdown--><p>使用<strong>BeautifulSoup(htmlMarkup,'html5lib')</strong>方法解析網頁內容，返回值(soup)為&lt;class 'bs4.BeautifulSoup'&gt;</p><!--kg-card-begin: markdown--><pre><code>soup = BeautifulSoup(resp.text,'html5lib')</code></pre>
<!--kg-card-end: markdown--><hr><h2 id="--2">取得內容<br></h2><h3 id="-json-1">目標為JSON</h3><p>以台灣證券交易所-201901月個股日成交資訊為例，網址為'<a href="https://www.twse.com.tw/exchangeReport/STOCK_DAY?response=json&amp;date=20190101&amp;stockNo=2881">https://www.twse.com.tw/exchangeReport/STOCK_DAY?response=json&amp;date=20190101&amp;stockNo=2881</a>'，該請求返回的內容如下圖</p><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2020/01/bandicam-2020-01-03-22-28-14-255.jpg" class="kg-image" alt="使用Python爬蟲抓取網站資料"></figure><p>需使用Pandas模組裡的方法，使用以下指令載入該模組</p><!--kg-card-begin: markdown--><pre><code>import pandas as pd
</code></pre>
<!--kg-card-end: markdown--><p>我們需要取得data裡的0~20所有資訊做為內容，將其放入pandas的dataframe裡，並使用fields作為其欄位的標籤</p><!--kg-card-begin: markdown--><pre><code>//data[]為先前取得的資料，型態為字典
df = pd.DataFrame(data['data'],columns = data['fields'])</code></pre>
<!--kg-card-end: markdown--><p>若要使用foreach迴圈讀取或印出dataframe的內容時，需使用<strong>df.values</strong>作為範圍，若只使用df作為範圍會得到錯誤的結果</p><!--kg-card-begin: markdown--><pre><code>for row in df:
    print(row)
</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>&gt;日期
成交股數
成交金額
開盤價
最高價
最低價
收盤價
漲跌價差
成交筆數</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>for row in df.values:
    print(row)</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>&gt;['108/10/01' '8,895,183' '399,156,974' '44.85' '45.00' '44.75' '45.00' '+0.45' '3,310']
['108/10/02' '4,399,985' '196,735,002' '44.55' '44.85' '44.55' '44.75' '-0.25' '1,745']
...
['108/10/31' '17,527,040' '787,119,996' '45.40' '45.40' '44.55' '44.55' '-0.90' '5,017']</code></pre>
<!--kg-card-end: markdown--><h3 id="-html--1">目標為HTML網頁內容</h3><p>類別為'bs4.BeautifulSoup'的物件可使用以下方法<br><br>find()	//查詢第一筆符合的資料<br>find(htmlTag)	//查詢標籤類型為htmlTag的第一筆元素<br>find(id='elementID')	//查詢id為elementID的元素<br>find(htmlTag,class_='className')	//查詢標籤為htmlTag且class為className的第一筆元素<br>find(htmlTag,className)	//查詢標籤為htmlTag且class為className的第一筆元素<br><br>find_all()	//查詢所有符合的元素<br>find_all(htmlTag)	//查詢所有符合標籤類型為htmlTag的元素<br>find_all(id='elementID')	//查詢id為elementID的元素<br>find_all(htmlTag,class_='className')	//查詢標籤為htmlTag且class為className的所有元素<br>find_all(htmlTag,className)	//查詢標籤為htmlTag且class為className的所有元素</p><p>若使用find_all()查詢，可使用foreach迴圈歷遍所有查找到的元素</p><!--kg-card-begin: markdown--><pre><code>for content in soup.find_all('li'):
    print(content.string)</code></pre>
<!--kg-card-end: markdown--><p>使用<strong>.string</strong>方法取得元素的內容</p><!--kg-card-begin: markdown--><pre><code>soup = BeautifulSoup('&lt;h1 id=&quot;thisish1&quot;&gt;content&lt;/h1&gt;', 'html5lib')
print(soup.h1)</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>&gt;&lt;h1 id=&quot;thisish1&quot;&gt;content&lt;/h1&gt;</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>soup = BeautifulSoup('&lt;h1 id=&quot;thisish1&quot;&gt;content&lt;/h1&gt;', 'html5lib')
print(soup.h1.string)</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>&gt;content</code></pre>
<!--kg-card-end: markdown--><p>使用get('href')方法取得元素的href屬性</p><!--kg-card-begin: markdown--><pre><code>soup = BeautifulSoup('&lt;h1 href=&quot;katsuobushi.com&quot;&gt;content&lt;/h1&gt;', 'html5lib')
print(soup.h1.get('href'))</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>&gt;katsuobushi.com</code></pre>
<!--kg-card-end: markdown--><hr><h2 id="--3">輸出為檔案<br></h2><h3 id="-csv-">輸出為csv檔案</h3><p>需載入os及csv模組以使用open及writer方法</p><!--kg-card-begin: markdown--><pre><code>import os
import csv</code></pre>
<!--kg-card-end: markdown--><p>使用w模式開啟檔案，w模式為打開一個文件只用於寫入，若文件已存在則打开文件，並從頭開始編輯，原有内容會被刪除。若文件不存在，則創建新文件。</p><!--kg-card-begin: markdown--><pre><code>file = open(filepath,'w',newline='',encoding='utf-8-sig')</code></pre>
<!--kg-card-end: markdown--><p>使用csv.writer()創建一個writer</p><!--kg-card-begin: markdown--><pre><code>csvWriter = csv.writer(file)</code></pre>
<!--kg-card-end: markdown--><p>writerow()方法可將一列資料寫入到檔案中</p><!--kg-card-begin: markdown--><pre><code>csvWriter.writerow(row)</code></pre>
<!--kg-card-end: markdown--><p>寫入完畢後須關閉檔案，釋放資源</p><!--kg-card-begin: markdown--><pre><code>file.close()</code></pre>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[從外部中斷Goroutine]]></title><description><![CDATA[想要從外部終止一個正在執行中或無限迴圈的goroutine，必須使用channel將中斷訊息傳入使之中斷]]></description><link>http://localhost:2368/golang-kill-goroutine/</link><guid isPermaLink="false">5e019b6b9d3d371b842d0b37</guid><category><![CDATA[golang]]></category><category><![CDATA[goroutine]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Tue, 24 Dec 2019 06:29:39 GMT</pubDate><media:content url="http://localhost:2368/content/images/2019/12/golang-long-1.jpeg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2019/12/golang-long-1.jpeg" alt="從外部中斷Goroutine"><p></p><p>想要從外部終止一個正在執行中或無限迴圈的goroutine，必須使用channel將中斷訊息傳入使之中斷</p><hr><h3 id="-channel">建立Channel</h3><p>使用<strong>chan</strong>關鍵字宣告為channel，並指定通道類型</p><!--kg-card-begin: markdown--><pre><code>ch := make(chan struct{})</code></pre>
<!--kg-card-end: markdown--><p>若要傳入channel多個值，則必須指定buffer的大小，否則會造成deadlock</p><!--kg-card-begin: markdown--><pre><code>ch := make(chan struct{},10)//buffer大小為10</code></pre>
<!--kg-card-end: markdown--><p>設定目標函式的參數</p><!--kg-card-begin: markdown--><pre><code>func main(){
    ch := make(chan struct{})
    go spinner(80*time.Millisecond, ch)
}

func spinner(delay time.Duration, ch chan struct{}) {
    
}</code></pre>
<!--kg-card-end: markdown--><h3 id="-select-case-">使用select case控制流程</h3><p>select case只能用在有關channel的操作上，若多個case都符合，則會隨機挑選一個執行，若都不符合則執行default</p><!--kg-card-begin: markdown--><pre><code>func main(){
    ch := make(chan struct{})
    go spinner(80*time.Millisecond, ch)
}

func spinner(delay time.Duration, ch chan struct{}) {
    for {
        select {
        case &lt;-ch:
            return
        default:
            for _, r := range `-\|/` {
                fmt.Printf(&quot;\r%c&quot;, r)
                time.Sleep(delay)
            }
        }
    }
}</code></pre>
<!--kg-card-end: markdown--><h3 id="-goroutine">結束goroutine</h3><p>在要中斷的地方插入close(ch)以關閉channel</p><!--kg-card-begin: markdown--><pre><code>func main(){
    ch := make(chan struct{})
    go spinner(80*time.Millisecond, ch)
    close(ch)
}

func spinner(delay time.Duration, ch chan struct{}) {
    for {
        select {
        case &lt;-ch:
            return
        default:
            for _, r := range `-\|/` {
                fmt.Printf(&quot;\r%c&quot;, r)
                time.Sleep(delay)
            }
        }
    }
}</code></pre>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[Golang函式]]></title><description><![CDATA[Golang基礎 - 函式]]></description><link>http://localhost:2368/golang-function/</link><guid isPermaLink="false">5dfde8756c21ff2c7860dae4</guid><category><![CDATA[golang]]></category><category><![CDATA[golangBasic]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Sat, 21 Dec 2019 12:49:49 GMT</pubDate><media:content url="http://localhost:2368/content/images/2019/12/golang-long.jpeg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2019/12/golang-long.jpeg" alt="Golang函式"><p></p><h3 id="-">基本用法</h3><p>最基本的用法為使用func作為宣告函式的關鍵字，後面接上函式名稱(test)及回傳值(string)，這裡要注意的是必須指定回傳型態，否則會跳出錯誤訊息"too many arguments to return"</p><!--kg-card-begin: markdown--><pre><code>func test() string{
    return &quot;Hello&quot; 
}

func main(){
    fmt.Println(test())
}</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>&gt;Hello</code></pre>
<!--kg-card-end: markdown--><h3 id="--1">多個回傳值</h3><p>golang可以一次回傳多個值，在呼叫的地方必須使用多個變數接收傳回來的值</p><!--kg-card-begin: markdown--><pre><code>func test() (string,string){
    return &quot;Hello&quot;,&quot;katsuobushi&quot;
}

func main(){
    hlo,name := test()
    fmt.Println(hlo , name)
}</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>&gt;Hello katsuobushi</code></pre>
<!--kg-card-end: markdown--><h3 id="--2">傳入參數</h3><p>在函式名稱後的括號內加入一個或多個"<strong>變數名稱 變數型態"</strong>，以傳入參數</p><!--kg-card-begin: markdown--><pre><code>func foo(name string,age int){
    fmt.Println(name,age)
}

func main(){
    foo(&quot;katsuobushi&quot;,100)
}</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>&gt;katsuobushi 100
</code></pre>
<!--kg-card-end: markdown--><h3 id="--3">為回傳值命名</h3><p>可為回傳變數命名(宣告變數)，在回傳時可直接呼叫<strong>return</strong>就可以了</p><!--kg-card-begin: markdown--><pre><code>func foo(str string) (returnStr string) {
    returnStr = str
    return
}

func main() {
    fmt.Println(foo(&quot;Hello&quot;))
}</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>&gt;Hello</code></pre>
<!--kg-card-end: markdown--><h3 id="--4">類別的方法</h3><p>這個應該歸在類別裡介紹，但自己曾經搞混過所以在這裡註記下，這是類別裡宣告方法的方式，在函式的前面加上<strong>"(變數名稱 *類別)"</strong>，即表示宣告該類別的一個方法</p><p>在方法中使用<strong>變數名稱.方法</strong>或<strong>變數名稱.屬性</strong>表示存取呼叫該方法的物件(本例為co物件)的方法或屬性</p><p>假設使用co物件呼叫setCourse方法，則在setCourse方法裡的c即代表co物件，而c.courseID就代表co物件裡的courseID屬性</p><!--kg-card-begin: markdown--><pre><code>type course struct {
    courseID      string
    courseTeacher string
}

func (c *course) setCourse(id string, teacher string) {
    c.courseID = id
    c.courseTeacher = teacher
}

func (c *course) print() {
    fmt.Println(c.courseID, c.courseTeacher)
}

func main() {
    var co course
    co.setCourse(&quot;3452&quot;, &quot;GolangProgramming&quot;)
    co.print()
}
</code></pre>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[計算Wildcard Mask]]></title><description><![CDATA[在設置ACL(Access Control List)時，會用到Wildcard Mask標示在範圍內的IP位址，這篇筆記記錄如何使用wildcard mask計算IP範圍的起點及終點]]></description><link>http://localhost:2368/wildcard-mask/</link><guid isPermaLink="false">5df3b117bd62740960b57409</guid><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Fri, 13 Dec 2019 16:49:37 GMT</pubDate><media:content url="http://localhost:2368/content/images/2019/12/binary-code-binary-binary-system-byte-bits-administrator-1458897-pxhere.com.jpg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2019/12/binary-code-binary-binary-system-byte-bits-administrator-1458897-pxhere.com.jpg" alt="計算Wildcard Mask"><p></p><p>在設置ACL(Access Control List)時，會用到Wildcard Mask標示在範圍內的IP位址，這篇筆記記錄如何使用wildcard mask計算IP範圍的起點及終點</p><hr><h2 id="-">簡介<br></h2><p>wildcard mask使用0和1表示<br>0代表匹配，1代表忽略<br>以下使用8bit作為示範</p><!--kg-card-begin: markdown--><table>
<thead>
<tr>
<th>128</th>
<th>64</th>
<th>32</th>
<th>16</th>
<th>8</th>
<th>4</th>
<th>2</th>
<th>1</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>匹配所有位元</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>忽略後六個位元</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>忽略後四個位元</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>忽略前六個位元</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>忽略所有位元</td>
</tr>
</tbody>
</table>
<!--kg-card-end: markdown--><hr><h2 id="--1">計算<br></h2><p>以指令 <strong>access list 50 permit 192.168.122.128 0.0.0.63</strong> 為例</p><!--kg-card-begin: markdown--><table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">DEC</th>
<th style="text-align:center">BIN</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IP Address</td>
<td style="text-align:center">192.168.122.128</td>
<td style="text-align:center">11000000.10101000.01111010.10000000</td>
</tr>
<tr>
<td style="text-align:center">Wildcard Mask</td>
<td style="text-align:center">0.0.0.63</td>
<td style="text-align:center">00000000.00000000.00000000.00111111</td>
</tr>
<tr>
<td style="text-align:center">IP位址範圍起點</td>
<td style="text-align:center">192.168.122.128</td>
<td style="text-align:center">11000000.10101000.01111010.10000000</td>
</tr>
<tr>
<td style="text-align:center">IP位址範圍終點</td>
<td style="text-align:center">192.168.122.191</td>
<td style="text-align:center">11000000.10101000.01111010.10111111</td>
</tr>
</tbody>
</table>
<!--kg-card-end: markdown--><p>1.計算IP位址的二進位值<br>    192.168.122.128 -&gt; 11000000.10101000.01111010.10000000<br>2.計算Mask的二進位值<br>    0.0.0.63 -&gt; 00000000.00000000.00000000.00111111<br>3.觀察Mask的值為最後6個bit，故範圍為10000000~10111111</p><p></p><p>以指令 <strong>access list 50 permit 192.51.100.58 0.0.0.63</strong> 為例</p><!--kg-card-begin: markdown--><table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">DEC</th>
<th style="text-align:center">BIN</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IP Address</td>
<td style="text-align:center">192.51.100.58</td>
<td style="text-align:center">11000000.00110011.01100100.00111010</td>
</tr>
<tr>
<td style="text-align:center">Wildcard Mask</td>
<td style="text-align:center">0.0.0.63</td>
<td style="text-align:center">00000000.00000000.00000000.00111111</td>
</tr>
<tr>
<td style="text-align:center">IP位址範圍起點</td>
<td style="text-align:center">192.51.100.0</td>
<td style="text-align:center">11000000.00110011.01100100.00000000</td>
</tr>
<tr>
<td style="text-align:center">IP位址範圍終點</td>
<td style="text-align:center">192.51.100.63</td>
<td style="text-align:center">11000000.00110011.01100100.00111111</td>
</tr>
</tbody>
</table>
<!--kg-card-end: markdown--><p>1.計算IP位址的二進位值<br>    192.51.100.58 -&gt; 11000000.00110011.01100100.00111010<br>2.計算Mask的二進位值<br>    0.0.0.63 -&gt; 00000000.00000000.00000000.00111111<br>3.觀察Mask的值為最後6個bit，故範圍為00000000~00111111</p><p><br>        </p>]]></content:encoded></item><item><title><![CDATA[使用Ghost和GitHub Pages建立網頁]]></title><description><![CDATA[一直以來都有個困擾，就是查個程式寫法或是軟體操作方法每次都很快就忘記，所以想寫個Blog紀錄自己的手順，先前曾想過直接寫個網頁PUSH到GitHub上，但實在有點累( ˘･з･)，偶然又看到有個很喜歡的排版是用Ghost建立的，因此使用Ghost+GitHub的形式建立部落格]]></description><link>http://localhost:2368/ghost-github-webpage/</link><guid isPermaLink="false">5de291f8c31a24007887a233</guid><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Sat, 30 Nov 2019 17:57:56 GMT</pubDate><media:content url="http://localhost:2368/content/images/2019/11/Ghost-Logo.svg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2019/11/Ghost-Logo.svg" alt="使用Ghost和GitHub Pages建立網頁"><p></p><p>一直以來都有個困擾，就是查個程式寫法或是軟體操作方法每次都很快就忘記，所以想寫個Blog紀錄自己的手順，先前曾想過直接寫個網頁PUSH到GitHub上，但實在有點累( ˘･з･)，偶然又看到有個很喜歡的排版是用Ghost建立的，因此使用Ghost+GitHub的形式建立部落格</p><hr><h2 id="-ghost">安裝Ghost</h2><p>1.安裝Ghost-CLI‌‌   使用npm或yarn指令安裝Ghost-CLI</p><!--kg-card-begin: markdown--><pre><code>npm install ghost-cli@latest -g</code></pre>
<!--kg-card-end: markdown--><p>2.安裝Ghost‌‌   開啟終端機，移動到要建立Ghost的目錄並使用指令安裝Ghost</p><!--kg-card-begin: markdown--><pre><code>ghost install local</code></pre>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/11/bandicam-2019-12-01-00-43-12-343-2.jpg" class="kg-image" alt="使用Ghost和GitHub Pages建立網頁"></figure><p>3.安裝完成後開啟git bash切換到同一目錄並初始化目錄</p><!--kg-card-begin: markdown--><pre><code>git init git add -A git commit -m &quot;Initial repository&quot;</code></pre>
<!--kg-card-end: markdown--><p>4.安裝npm並更新repository</p><!--kg-card-begin: markdown--><pre><code>npm install 
git add -A 
git commit -m 'Installed Node dependencies'</code></pre>
<!--kg-card-end: markdown--><p>5.安裝knex-migrator並更新repository</p><!--kg-card-begin: markdown--><pre><code>npm install -g knex-migrator</code></pre>
<!--kg-card-end: markdown--><p>6.初始化資料庫</p><!--kg-card-begin: markdown--><pre><code>knex-migrator</code></pre>
<!--kg-card-end: markdown--><hr><h2 id="-ghost-1">設定Ghost</h2><p>1.移動到已安裝Ghost的目錄並輸入指令開啟Ghost</p><!--kg-card-begin: markdown--><pre><code>ghost start</code></pre>
<!--kg-card-end: markdown--><p>2.一般使用<a href="http://localhost:2368/ghost">http://localhost:2368/ghost</a>開啟Ghost的管理介面，但因為先前已經在另一個地方裝過一個Ghost，所以畫面顯示以<a href="http://localhost:2369/ghost/">http://localhost:2369/ghost</a>/開啟管理介面</p><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/11/bandicam-2019-12-01-00-50-41-339-1.jpg" class="kg-image" alt="使用Ghost和GitHub Pages建立網頁"></figure><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/11/bandicam-2019-12-01-00-54-54-621-1.jpg" class="kg-image" alt="使用Ghost和GitHub Pages建立網頁"></figure><p>3.填寫網站名稱及作者基本資料</p><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/11/bandicam-2019-12-01-00-54-57-345-1.jpg" class="kg-image" alt="使用Ghost和GitHub Pages建立網頁"></figure><p>4.可輸入email邀請其他作者一起協作，只有自己使用的話則按下方直接進入管理介面</p><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/11/bandicam-2019-12-01-00-55-57-353-1.jpg" class="kg-image" alt="使用Ghost和GitHub Pages建立網頁"></figure><p>5.更新repository</p><!--kg-card-begin: markdown--><pre><code>git add -A 
git commit -m 'Finished local Ghost setup'</code></pre>
<!--kg-card-end: markdown--><hr><h2 id="-">將網頁輸出為檔案</h2><p>1.使用wget輸出網頁到docs資料夾內<br>   --mirror : 鏡像下載所有檔案相當於-N -r -l inf --no-remove-listing選項<br>        -N : 若遠端檔案較新則下載檔案<br>        -r : 遞迴下載<br>        -l : 最大搜尋深度(0或inf表示無限)<br>        --no-remove-listing : 不刪除<strong>.listing</strong>檔案<br>   --convert-links : 轉換檔案內路徑為符合本地目錄的路徑   <br>   --page-requisites : 下載所有顯示網頁所需的檔案，例如圖片等<br>   -nH : 不建立名稱為網站名稱的目錄，直接在當前目錄建立檔案<br>   --no-parent : 不進入上層目錄<br>   -P : 指定下載目錄</p><!--kg-card-begin: markdown--><pre><code>wget --mirror --convert-links --page-requisites -nH --no-parent -P docs http://localhost:2368/</code></pre>
<!--kg-card-end: markdown--><p>2.由於從Ghost抓下來的css、js的檔名和html內的相關路徑都會被加上類似下圖.css後方的字串，若直接傳到GitHub Pages上的話會讀不到，我們可使用Notepad++將目錄中所有檔案中有包括此字串的替換為空字串</p><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/11/bandicam-2019-12-01-01-13-41-348-1.jpg" class="kg-image" alt="使用Ghost和GitHub Pages建立網頁"></figure><p>3.開啟Notepad++，點選<strong>在檔案中尋找</strong></p><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/11/bandicam-2019-12-01-01-19-16-765-1.jpg" class="kg-image" alt="使用Ghost和GitHub Pages建立網頁"></figure><p>4.輸入要刪除的字串並按下<strong>在多個檔案中取代</strong></p><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/11/bandicam-2019-12-01-01-23-25-708-1.jpg" class="kg-image" alt="使用Ghost和GitHub Pages建立網頁"></figure><p>5.更改docs/assets內built、css和js資料夾內所有包含該字串的檔名</p><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/11/bandicam-2019-12-01-01-27-47-025-1.jpg" class="kg-image" alt="使用Ghost和GitHub Pages建立網頁"></figure><p>6.更新repository</p><!--kg-card-begin: markdown--><pre><code>git add -A 
git commit -m &quot;Export website to docs file;&quot;</code></pre>
<!--kg-card-end: markdown--><hr><h2 id="push-github">PUSH檔案到GitHub</h2><p>1.設定遠端倉庫</p><!--kg-card-begin: markdown--><pre><code>git remote add origin &lt;webURL|SSH Key&gt;</code></pre>
<!--kg-card-end: markdown--><p>2.將master分支推送到origin倉庫</p><!--kg-card-begin: markdown--><pre><code>git push -u origin master</code></pre>
<!--kg-card-end: markdown--><hr><h2 id="-github-pages">設定GitHub Pages</h2><p>1.進入剛剛上傳的GitHub的Repository，點選settings標籤</p><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/11/bandicam-2019-12-01-01-39-39-594-1.jpg" class="kg-image" alt="使用Ghost和GitHub Pages建立網頁"></figure><p>2.尋找GitHub Pages區塊，選擇master branch /docs folder作為網頁來源</p><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/11/bandicam-2019-12-01-01-42-52-205-1.jpg" class="kg-image" alt="使用Ghost和GitHub Pages建立網頁"></figure><hr><h2 id="--1">已可瀏覽網頁</h2><p>在網址列輸入http://帳號.github.io/RepositoryName即可瀏覽網頁</p>]]></content:encoded></item></channel></rss>
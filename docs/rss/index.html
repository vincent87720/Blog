<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[柴魚筆記本]]></title><description><![CDATA[程式 • 軟體 • 攝影]]></description><link>http://localhost:2368/</link><image><url>http://localhost:2368/favicon.png</url><title>柴魚筆記本</title><link>http://localhost:2368/</link></image><generator>Ghost 3.42</generator><lastBuildDate>Tue, 22 Jun 2021 19:16:09 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[[Pattern]REST API 設計規範]]></title><description><![CDATA[REST是一種架構風格，類似設計模式，使用一些原則規範應用程式的設計]]></description><link>http://localhost:2368/pattern-rest-api-design/</link><guid isPermaLink="false">60c7188467f493abc689cd41</guid><category><![CDATA[Pattern]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Mon, 14 Jun 2021 09:20:00 GMT</pubDate><media:content url="http://localhost:2368/content/images/2021/06/Vector-Computer-Pattern-Computer-Seamless-Background-Stock.jpg" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><img src="http://localhost:2368/content/images/2021/06/Vector-Computer-Pattern-Computer-Seamless-Background-Stock.jpg" alt="[Pattern]REST API 設計規範"><p>REST是一種架構風格，類似設計模式，使用一些原則規範應用程式的設計，以下為REST風格的一些特徵</p>
<h2 id>使用名詞而非動詞</h2>
<p>當我們想要設計一個學生的API時，應使用名詞進行定義</p>
<pre><code class="language-javascript">//這是對的
/students/1
</code></pre>
<p>而非使用動詞定義</p>
<pre><code class="language-javascript">//這是錯的
/getStudent/1
</code></pre>
<h2 id>使用複數名詞</h2>
<p>不區分單複數，全部使用複數定義</p>
<pre><code class="language-javascript">//這是對的
/students
</code></pre>
<p>不使用單數定義</p>
<pre><code class="language-javascript">//這是錯的
/student
</code></pre>
<h2 id>使用子資源表達資源間的關係</h2>
<p>以取得所有資源與特定資源為例</p>
<pre><code class="language-javascript">//這是對的
/students //取得所有學生
/students/1 //取得特定學生
</code></pre>
<p>呼應到使用複數名詞定義API，取得特定資源時不使用單數表達，而是使用子資源方式定義</p>
<pre><code class="language-javascript">//這是錯的
/students //取得所有學生
/student/1 //取得特定學生
</code></pre>
<h2 id="get">使用GET以外的方法改變資源狀態</h2>
<p>要改變資源狀態應使用GET以外的方法，例如POST、PUT或DELETE等</p>
<pre><code class="language-javascript">//這是對的
POST /students/1/activate
</code></pre>
<p>不使用GET進行修改</p>
<pre><code class="language-javascript">//這是錯的
GET /students/1/activate
</code></pre>
<h2 id="httpheader">使用HTTP header定義格式</h2>
<ul>
<li>Content-Type定義請求格式</li>
<li>Accept定義接收對應的格式列表</li>
</ul>
<h2 id="hateoas">使用HATEOAS約束</h2>
<p>用戶端可以在伺服器返回的內容中動態的取得URI的資訊，再使用取得的URI資訊送出請求</p>
<h2 id>提供過濾、排序、欄位選擇、分頁</h2>
<h3 id>過濾</h3>
<pre><code class="language-javascript">GET /students?gender=male
GET /students?age&lt;=18
</code></pre>
<h3 id>排序</h3>
<pre><code class="language-javascript">GET /students?sort=-age,+id
</code></pre>
<h3 id>欄位選擇</h3>
<pre><code class="language-javascript">GET /students?fields=id,name,age,gender
</code></pre>
<h3 id>分頁</h3>
<pre><code class="language-javascript">GET /students?offset=10&amp;limit=5 //取得學生第20個之後的5個學生
</code></pre>
<h2 id>使用版本</h2>
<p>使用版本編號將API版本化，提供彈性</p>
<pre><code class="language-javascript">/yourService/api/v1
</code></pre>
<h2 id="httpstatuscode">使用HTTP Status Code進行錯誤處理</h2>
<p>每個錯誤都須返回一個payload，不可僅返回錯誤狀態碼(500 Internal Server Error)</p>
<pre><code class="language-json">{
    &quot;errors&quot;:[
        {
            &quot;userMessage&quot;:&quot;Sorry, the requested resource dose not exists.&quot;,
            &quot;internalMessage&quot;:&quot;Student not found&quot;,
            &quot;code&quot;:&quot;34&quot;
        }
    ]
}
</code></pre>
<h2 id>參考資料</h2>
<ul>
<li>巨型公司的網路架構：分散是系統內部解密/柳偉衛</li>
</ul>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[[Golang]MySQL Error 1040: Too Many Connections 錯誤處理]]></title><description><![CDATA[前陣子寫了一個golang程式用來上傳資料到MySQL，起初程式運作都非常良好，過了一陣子開始出現代號為1040的Too Many Connections錯誤，我們一起來看看發生了甚麼事。]]></description><link>http://localhost:2368/golang-mysql-error-1040/</link><guid isPermaLink="false">60bf95efd94d554e3a9b2b57</guid><category><![CDATA[golang]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Tue, 08 Jun 2021 16:09:52 GMT</pubDate><media:content url="http://localhost:2368/content/images/2021/06/golang-long.jpeg" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><img src="http://localhost:2368/content/images/2021/06/golang-long.jpeg" alt="[Golang]MySQL Error 1040: Too Many Connections 錯誤處理"><p>前陣子寫了一個golang程式用來上傳資料到MySQL，起初程式運作都非常良好，過了一陣子開始出現代號為1040的Too Many Connections錯誤，我們一起來看看發生了甚麼事。</p>
<h2 id="mysql">查看MySQL的連線數量</h2>
<p>在MySQL下SQL查詢</p>
<pre><code class="language-sql">SHOW STATUS LIKE '%connected';
</code></pre>
<p>查詢結果如下</p>
<table>
<thead>
<tr>
<th>Variable_name</th>
<th style="text-align:left">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Slaves_connected</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td>Threads_connected</td>
<td style="text-align:left">151</td>
</tr>
</tbody>
</table>
<p>我們可以發現到Threads_connected已經到達151了，MySQL預設的最大允許連線數量為151，可以使用以下指令查詢最大允許連線數量</p>
<pre><code class="language-sql">SHOW VARIABLES LIKE 'max_connections';
</code></pre>
<h2 id>檢查程式碼</h2>
<p>後來檢查程式碼發現在database/sql這個package有兩個struct，一個是DB，另一個是Conn，我將DB物件的連線關掉而沒有關閉Conn物件的，導致連線數一直增加，造成1040錯誤。</p>
<h3 id>錯誤程式碼範例</h3>
<pre><code class="language-go">db, err := sql.Open(&quot;mysql&quot;, &quot;user:password@tcp(127.0.0.1)/testdb?charset=utf8&quot;)
if err != nil {
    fmt.Println(err)
}
defer db.Close()

_, err = db.Query(&quot;call SP(?,?,?,?)&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;)
if err != nil {
    fmt.Println(err)
}
</code></pre>
<p>我們可以看到上面關閉的是db.Close()，這樣並不能正確關閉連線，必須關閉db.Query的連線才能正確的降低連線卡住的數量</p>
<h3 id>修正程式碼範例</h3>
<pre><code class="language-go">db, err := sql.Open(&quot;mysql&quot;, &quot;user:password@tcp(127.0.0.1)/testdb?charset=utf8&quot;)
if err != nil {
    fmt.Println(err)
}
defer db.Close()

conn, err := db.Query(&quot;call SP(?,?,?,?)&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;)
if err != nil {
    fmt.Println(err)
}
defer conn.Close()

</code></pre>
<h2 id>參考資料</h2>
<ul>
<li><a href="https://stackoverflow.com/questions/39452555/is-it-normal-to-have-these-many-connections-in-mysql">stackoverflow - Is it normal to have these many connections in MySQL?</a></li>
</ul>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[[Zsh]更改Ubuntu終端機樣式]]></title><description><![CDATA[近期無意間在網路上發現Bullet Train這個theme，一下子就被燒到了，覺得非常好看，於是決定來將自己的terminal也改成那樣子，提昇~~爽度~~工作效率]]></description><link>http://localhost:2368/zsh-ubuntu-init/</link><guid isPermaLink="false">60ba55154b0bccce2a8deb75</guid><category><![CDATA[zsh]]></category><category><![CDATA[Ubuntu]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Fri, 04 Jun 2021 16:32:31 GMT</pubDate><media:content url="http://localhost:2368/content/images/2021/06/2021-06-05-00-26-14-------1.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><img src="http://localhost:2368/content/images/2021/06/2021-06-05-00-26-14-------1.png" alt="[Zsh]更改Ubuntu終端機樣式"><p>近期無意間在網路上發現<a href="https://github.com/caiogondim/bullet-train.zsh">Bullet Train</a>這個theme，一下子就被燒到了，覺得非常好看，於是決定來將自己的terminal也改成那樣子，提昇<s>爽度</s>工作效率</p>
<h2 id>環境</h2>
<ul>
<li>Ubuntu 20.04.2LTS</li>
</ul>
<h2 id>安裝</h2>
<p>更新套件清單</p>
<pre><code class="language-shell">$ sudo apt-get update #更新套件清單
$ sudo apt-get upgrade #根據已經更新的套件清單，比對是否更新套件
</code></pre>
<p>安裝Zsh</p>
<pre><code class="language-shell">$ sudo apt-get install zsh
</code></pre>
<p>查看Zsh是否成功安裝</p>
<pre><code class="language-shell">$ cat /etc/shells
</code></pre>
<p>安裝oh-my-zsh</p>
<pre><code class="language-shell">$ sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;
</code></pre>
<p>安裝完會顯示oh-my-zsh的歡迎畫面</p>
<h2 id>修改設定</h2>
<p>目前預設的還是Bash Shell，要將它改成Zsh</p>
<pre><code class="language-shell">$ chsh -s /bin/zsh
</code></pre>
<p>修改完成後須重新登入</p>
<h2 id="theme">安裝Theme</h2>
<p>前往<a href="https://github.com/caiogondim/bullet-train.zsh">Bullet train</a>下載<a href="https://raw.githubusercontent.com/caiogondim/bullet-train-oh-my-zsh-theme/master/bullet-train.zsh-theme">主題</a></p>
<p>將下載好的主題<strong>bullet-train.zsh-theme</strong>放入<code>.oh-my-zsh/themes</code>目錄內</p>
<p>接著編輯<code>~/.zshrc</code>，將<strong>ZSH_THEME</strong>設定為&quot;bullet-train&quot;</p>
<h2 id="powerline">安裝powerline</h2>
<pre><code class="language-shell">$ sudo apt-get install powerline
$ sudo apt-get install fonts-powerline
</code></pre>
<h2 id="melso">安裝Melso字型</h2>
<pre><code class="language-shell">$ git clone https://github.com/powerline/fonts.git --depth=1
$ cd fonts 
$ ./install.sh
</code></pre>
<p>右鍵點選Terminal&gt;偏好設定&gt;文字&gt;自訂字型，選擇<strong>Meslo LG S for Powerline Bold</strong>更改字型</p>
<h2 id>參考資料</h2>
<ul>
<li><a href="https://medium.com/@wifferlin0505/%E5%9C%A8-ubuntu-16-04-lts-%E4%B8%AD%E5%AE%89%E8%A3%9D%E4%BD%BF%E7%94%A8-oh-my-zsh-cf92203ca8a2">在 Ubuntu 18.04 LTS / 16.04 LTS 中安裝使用 Oh-My-Zsh</a></li>
<li><a href="https://medium.com/@hazelwu/%E7%94%A8oh-my-zsh%E6%8A%8Aiterm%E8%AE%8A%E7%BE%8E%E7%BE%8E-8a18daa8eac">用Oh My Zsh把iTerm變美美</a></li>
<li><a href="https://github.com/caiogondim/bullet-train.zsh">Github - Bullet Train for oh-my-zsh</a></li>
<li><a href="https://github.com/powerline/fonts">Github - Powerline fonts</a></li>
<li><a href="https://github.com/agnoster/agnoster-zsh-theme">agnoster.zsh-theme</a></li>
</ul>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[[ESP8266]ESP-01韌體燒錄]]></title><description><![CDATA[在使用ESP8266有時會遇到兩種情況，原廠出貨的韌體怪怪的導致無法使用AT指令跟ESP8266溝通，或是已經把自己的程式燒進去之後又想重新使用AT指令的功能，這時候就需要重新燒錄韌體，這篇筆記紀錄使用ESP-01作為範例的韌體燒錄及AT指令驗證步驟]]></description><link>http://localhost:2368/flash-firmware-on-esp01/</link><guid isPermaLink="false">6033ae12b40e5a0c5c7b4eac</guid><category><![CDATA[ESP8266]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Mon, 22 Feb 2021 13:42:24 GMT</pubDate><media:content url="http://localhost:2368/content/images/2021/02/pexels-skitterphoto-1448561.jpg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2021/02/pexels-skitterphoto-1448561.jpg" alt="[ESP8266]ESP-01韌體燒錄"><p>在使用ESP8266有時會遇到兩種情況，原廠出貨的韌體怪怪的導致無法使用AT指令跟ESP8266溝通，或是已經把自己的程式燒進去之後又想重新使用AT指令的功能，這時候就需要重新燒錄韌體，這篇筆記紀錄使用ESP-01作為範例的韌體燒錄及AT指令驗證步驟</p><!--kg-card-begin: markdown--><h2 id>材料</h2>
<h3 id>硬體</h3>
<ul>
<li>ESP-01s</li>
<li>ESP-01燒錄器</li>
</ul>
<h3 id>軟體</h3>
<ul>
<li>Flash Download Tools (ESP8266 &amp; ESP32 &amp; ESP32-S2) V3.8.5</li>
<li>RealTerm 2.0.0.70</li>
</ul>
<h3 id="sdk">SDK</h3>
<ul>
<li>ESP8266 NONOS SDK V3.0.4</li>
</ul>
<h3 id="at">AT指令集(含韌體燒錄位址說明)</h3>
<ul>
<li>ESP8266 Non-OS AT Instruction Set V3.0.3</li>
</ul>
<h2 id>準備所需軟體及韌體</h2>
<p>點擊下方連結下載燒錄工具、韌體及指令集</p>
<ul>
<li><a href="https://www.espressif.com/en/support/download/sdks-demos">ESP8266 NONOS SDK</a></li>
<li><a href="https://www.espressif.com/en/support/download/other-tools">Flash Download Tools</a></li>
<li><a href="https://www.espressif.com/en/support/documents/technical-documents">ESP8266 Non-OS AT Instruction Set</a></li>
</ul>
<h2 id="esp01">連接ESP-01</h2>
<p>將ESP-01插在燒錄器上，並將燒錄器插入USB Port<br>
接著按下<code>Windows鍵+R</code>，輸入<strong>devmgmt.msc</strong>按下確定，進入裝置管理員查看燒錄器的COM Port(範例為COM7)<br>
<img src="http://localhost:2368/content/images/2021/02/1.png" alt="[ESP8266]ESP-01韌體燒錄"></p>
<h2 id>設定燒錄資訊</h2>
<p>點擊<code>flash_download_tool_3.8.5.exe</code>執行燒錄程式<br>
<img src="http://localhost:2368/content/images/2021/02/2.png" alt="[ESP8266]ESP-01韌體燒錄"></p>
<p>選擇<code>Developer Mode</code><br>
<img src="http://localhost:2368/content/images/2021/02/3.png" alt="[ESP8266]ESP-01韌體燒錄"></p>
<p>選擇<code>ESP8266 DownloadTool</code><br>
<img src="http://localhost:2368/content/images/2021/02/4.png" alt="[ESP8266]ESP-01韌體燒錄"></p>
<p>韌體燒錄位址表在<code>AT指令集</code>裡可以找到，在<strong>1.2. Downloading AT Firmware into the Flash</strong>裡的<strong>1.2.4. 8 Mbit Flash</strong>有詳細說明<br>
<img src="http://localhost:2368/content/images/2021/02/5.png" alt="[ESP8266]ESP-01韌體燒錄"></p>
<p><img src="http://localhost:2368/content/images/2021/02/6.png" alt="[ESP8266]ESP-01韌體燒錄"></p>
<p>解壓縮已經下載好的<code>ESP8266_NONOS_SDK-3.0.4</code>檔案，在裡面尋找bin資料夾，裡面的檔案就是燒錄所需的檔案，依照韌體燒錄位址表進行設定，將特定檔案對上相對的位址，並將左邊方格打勾</p>
<p><code>FLASH SIZE</code>記得要改為8Mbit(ESP-01的Flash size為1MB，也就是8Mbit)</p>
<p>右下角的COM選單選擇剛才在裝置管理員看到的COM Port編號</p>
<p>BAUD設為<strong>115200</strong></p>
<p><img src="http://localhost:2368/content/images/2021/02/7.png" alt="[ESP8266]ESP-01韌體燒錄"></p>
<h2 id>執行韌體燒錄程式</h2>
<p>設定完成之後按下<code>START</code>按鈕便可開始進行燒錄</p>
<p>若有抓到ESP-01會顯示<strong>Download下載中...</strong>，後面的方格也會顯示ESP-01的MAC位址</p>
<p><img src="http://localhost:2368/content/images/2021/02/8.png" alt="[ESP8266]ESP-01韌體燒錄"></p>
<p>若燒錄成功會顯示<strong>FINISH完成</strong></p>
<p><img src="http://localhost:2368/content/images/2021/02/9.png" alt="[ESP8266]ESP-01韌體燒錄"></p>
<h2 id>檢查燒錄狀態</h2>
<p>開啟RealTerm終端機程式</p>
<p>在<strong>Display</strong>頁籤設定Display As <strong>Ansi</strong><br>
<img src="http://localhost:2368/content/images/2021/02/10.png" alt="[ESP8266]ESP-01韌體燒錄"></p>
<p>在<strong>Port</strong>頁籤設定</p>
<ul>
<li>Baud為<strong>115200</strong>(若無回應可嘗試其他BaudRate)</li>
<li>Port為USB燒錄器的COM Port編號(可至裝置管理員確認，或移除裝置後重新插上以便確認)</li>
<li>重新按壓Open按鈕，確認為壓下狀態(有任何更改都可以重新按壓，確保狀態有被改變)</li>
<li>確認右下角狀態是否正確</li>
</ul>
<p><img src="http://localhost:2368/content/images/2021/02/11.png" alt="[ESP8266]ESP-01韌體燒錄"></p>
<p>在<strong>Send</strong>頁籤<strong>勾選EOL的前兩個</strong>，輸入要傳送的指令後按下Send ASCII即可傳送指令</p>
<ul>
<li>AT - 測試AT是否已啟動</li>
<li>AT+GMR - 查詢AT及SDK的版本資訊</li>
</ul>
<p><img src="http://localhost:2368/content/images/2021/02/12.png" alt="[ESP8266]ESP-01韌體燒錄"></p>
<p><img src="http://localhost:2368/content/images/2021/02/13.png" alt="[ESP8266]ESP-01韌體燒錄"></p>
<p>若送出指令AT有返回OK，且送出指令AT+GMR有返回版本資訊便可開始使用ESP-01了</p>
<h2 id>參考資料</h2>
<p><a href="https://www.espressif.com/en">ESPRESSIF</a><br>
<a href="https://www.espressif.com/en/support/download/sdks-demos">ESP8266 NONOS SDK</a><br>
<a href="https://www.espressif.com/en/support/download/other-tools">Flash Download Tools</a><br>
<a href="https://www.espressif.com/en/support/documents/technical-documents">ESP8266 Non-OS AT Instruction Set</a><br>
<a href="https://laoweizz.blogspot.com/2017/02/esp8266-esp-01s-01-usb-ttl-esp6288-wifi.html">ESP8266 ESP-01s測試(01)利用USB 轉TTL模組</a></p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[[IDE]在Visual Studio Code中使用MSYS作為終端機]]></title><description><![CDATA[因為需要用到Makefile的緣故，而windows沒有提供相關的功能，所以希望能夠把Visual studio code預設的powershell改為MSYS作為終端機，便於make指令的操作]]></description><link>http://localhost:2368/ide-vscode-terminal-using-msys/</link><guid isPermaLink="false">60095c7f31b2a401081db783</guid><category><![CDATA[VisualStudioCode]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Thu, 21 Jan 2021 10:59:50 GMT</pubDate><media:content url="http://localhost:2368/content/images/2021/01/visualStudioCode.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><img src="http://localhost:2368/content/images/2021/01/visualStudioCode.png" alt="[IDE]在Visual Studio Code中使用MSYS作為終端機"><p>因為需要用到Makefile的緣故，而windows沒有提供相關的功能，所以希望能夠把Visual studio code預設的powershell改為MSYS作為終端機，便於make指令的操作</p>
<h2 id>環境</h2>
<ul>
<li>Windows10 x64 2004</li>
<li>MSYS2</li>
<li>Visual Studio Code 1.52.1</li>
</ul>
<h2 id="visualstudiocodesettingsjson">開啟Visual studio code的settings.json</h2>
<h3 id>開啟設定介面</h3>
<h4 id="1">方法1 : 使用選單開啟</h4>
<p>點選左上角的File &gt; Preferences &gt; Settings<br>
<img src="http://localhost:2368/content/images/2021/01/1.png" alt="[IDE]在Visual Studio Code中使用MSYS作為終端機"></p>
<h4 id="2">方法2 : 使用快捷鍵開啟</h4>
<p>點擊空白處並按下快捷鍵<code>ctrl</code>+<code>,</code></p>
<h3 id="settingsjson">設定settings.json</h3>
<p>點選右上角的OpenSettings(JSON)按鈕<br>
<img src="http://localhost:2368/content/images/2021/01/2.png" alt="[IDE]在Visual Studio Code中使用MSYS作為終端機"></p>
<h3 id>在大括號中加入以下設定</h3>
<pre><code class="language-json">    &quot;terminal.integrated.shell.windows&quot;: &quot;C:\\msys64\\usr\\bin\\bash.exe&quot;,
    &quot;terminal.integrated.shellArgs.windows&quot;: [&quot;--login&quot;, &quot;-i&quot;],
</code></pre>
<p><em>注意! &quot;terminal.integrated.shell.windows&quot;設定的路徑需依照自己電腦上MSYS的路徑進行設定</em><br>
<img src="http://localhost:2368/content/images/2021/01/3.png" alt="[IDE]在Visual Studio Code中使用MSYS作為終端機"></p>
<h3 id>完成</h3>
<p>修改後重新開啟終端機就可以使用MSYS2作為終端機了<br>
<img src="http://localhost:2368/content/images/2021/01/4.png" alt="[IDE]在Visual Studio Code中使用MSYS作為終端機"></p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[[MQTT]Mosquitto Server 安裝與啟動]]></title><description><![CDATA[在使用MQTT進行資料傳遞時，會需要一個代理人，也就是MQTT Broker，作為訂閱/發布的橋樑，Mosquitto Server是一個開源的MQTT的Server，本篇筆記紀錄在Windows下如何安裝並開啟MQTT Server]]></description><link>http://localhost:2368/mqtt-mosquitto-server-init/</link><guid isPermaLink="false">5fbd476923e6d4238ca4b81e</guid><category><![CDATA[mqtt]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Tue, 24 Nov 2020 18:53:17 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/11/MQTT.png" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2020/11/MQTT.png" alt="[MQTT]Mosquitto Server 安裝與啟動"><p>在使用MQTT進行資料傳遞時，會需要一個代理人，也就是MQTT Broker，作為訂閱/發布的橋樑，Mosquitto Server是一個開源的MQTT的Server，本篇筆記紀錄在Windows下如何安裝並開啟MQTT Server</p><!--kg-card-begin: markdown--><h2 id>環境</h2>
<ul>
<li>Windows10 x64 2004</li>
<li>mosquitto-1.6.12a</li>
</ul>
<h2 id>下載</h2>
<p>進入<a href="https://mosquitto.org/download/">Mosquitto-Download</a>下載頁面進行下載<br>
<img src="http://localhost:2368/content/images/2020/11/1-2.png" alt="[MQTT]Mosquitto Server 安裝與啟動"></p>
<h2 id>安裝</h2>
<p>點擊已下載完成的安裝檔進行安裝<br>
<img src="http://localhost:2368/content/images/2020/11/2-2.png" alt="[MQTT]Mosquitto Server 安裝與啟動"><br>
<img src="http://localhost:2368/content/images/2020/11/3-2.png" alt="[MQTT]Mosquitto Server 安裝與啟動"><br>
可選擇安裝路徑<br>
<img src="http://localhost:2368/content/images/2020/11/4-2.png" alt="[MQTT]Mosquitto Server 安裝與啟動"><br>
安裝完成<br>
<img src="http://localhost:2368/content/images/2020/11/5-1.png" alt="[MQTT]Mosquitto Server 安裝與啟動"></p>
<h2 id>啟動</h2>
<p>使用<strong>工作管理員</strong>或<strong>執行</strong>開啟<strong>服務</strong>功能</p>
<h3 id>使用工作管理員開啟服務</h3>
<p>在開始列點選右鍵，點擊&quot;工作管理員&quot;以開啟<br>
<img src="http://localhost:2368/content/images/2020/11/6-1.png" alt="[MQTT]Mosquitto Server 安裝與啟動"></p>
<h3 id>使用執行開啟服務</h3>
<p>按下快捷鍵<code>windows+R</code>並輸入services.msc開啟服務功能<br>
<img src="http://localhost:2368/content/images/2020/11/7-1.png" alt="[MQTT]Mosquitto Server 安裝與啟動"></p>
<p>尋找mosquitto並點選右鍵啟動服務<br>
<img src="http://localhost:2368/content/images/2020/11/8-1.png" alt="[MQTT]Mosquitto Server 安裝與啟動"><br>
<img src="http://localhost:2368/content/images/2020/11/9.png" alt="[MQTT]Mosquitto Server 安裝與啟動"></p>
<h2 id>查看伺服器狀態</h2>
<p>在終端機輸入<code>netstat -an</code>查看作用中的連線，以檢查伺服器是否正常運行<br>
<img src="http://localhost:2368/content/images/2020/11/10.png" alt="[MQTT]Mosquitto Server 安裝與啟動"></p>
<h2 id>在防火牆中開啟連接埠</h2>
<p>進入控制台 &gt; 系統及安全性 &gt; Windows Defender防火牆 &gt; 進階設定，或直接按下快捷鍵<code>windows+R</code>並輸入WF.msc，開啟<strong>具有進階安全性的 Windows Defender 防火牆</strong></p>
<p>在<strong>輸入規則</strong>中點選新增規則<br>
<img src="http://localhost:2368/content/images/2020/11/11.png" alt="[MQTT]Mosquitto Server 安裝與啟動"><br>
建立指定連接埠的規則<br>
<img src="http://localhost:2368/content/images/2020/11/12.png" alt="[MQTT]Mosquitto Server 安裝與啟動"><br>
輸入1883連接埠進行設定<br>
<img src="http://localhost:2368/content/images/2020/11/13.png" alt="[MQTT]Mosquitto Server 安裝與啟動"><br>
<img src="http://localhost:2368/content/images/2020/11/14.png" alt="[MQTT]Mosquitto Server 安裝與啟動"><br>
<img src="http://localhost:2368/content/images/2020/11/15.png" alt="[MQTT]Mosquitto Server 安裝與啟動"><br>
指定規則名稱<br>
<img src="http://localhost:2368/content/images/2020/11/16.png" alt="[MQTT]Mosquitto Server 安裝與啟動"></p>
<h2 id>安裝完成</h2>
<p>完成以上設定後就可以透過1883連接埠對MQTT Server進行連線啦</p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[[Vue]將Vue-Router加入到專案中]]></title><description><![CDATA[在使用vue時，有時會需要在畫面中切換component，這時vue-router就派上用場啦，vue-router常常被用在single-page application中，這次的期中專題因為要將舊網頁變成single-page app，所以必須先了解如何將vue-router加入到專案中，方便後續使用]]></description><link>http://localhost:2368/vue-vuerouter-init/</link><guid isPermaLink="false">5faab3648214a931cca9350d</guid><category><![CDATA[Vue]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Tue, 10 Nov 2020 15:39:37 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/11/vue-1.jpg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2020/11/vue-1.jpg" alt="[Vue]將Vue-Router加入到專案中"><p>在使用vue時，有時會需要在畫面中切換component，這時vue-router就派上用場啦，vue-router常常被用在single-page application中，這次的期中專題因為要將舊網頁變成single-page app，所以必須先了解如何將vue-router加入到專案中，方便後續使用</p><!--kg-card-begin: markdown--><h2 id>環境</h2>
<ul>
<li>Windows10 x64 2004</li>
<li>Node.js - v12.19.0</li>
<li>Vue - @vue/cli 4.5.8</li>
<li>vue-router@3.4.9</li>
</ul>
<h2 id="vuerouter">安裝Vue-Router</h2>
<p>要將Vue-Router加入到專案可使用CDN嵌入，或是使用npm安裝</p>
<h3 id="cdn">CDN</h3>
<p>在<code>&lt;head&gt;&lt;/head&gt;</code>標籤中加入下面這行標籤即可將Vue-Router加入到專案</p>
<pre><code class="language-htmlmixed">&lt;head&gt;
    &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
</code></pre>
<h3 id="npm">npm</h3>
<p>開啟終端機，並輸入以下指令，即可安裝Vue-Router</p>
<pre><code class="language-shell">npm install vue-router
</code></pre>
<h2 id="vue">建立Vue專案</h2>
<p>在使用Vue-Router之前建議先建立Vue專案，建立專案的方法請參考<a href="https://vincent87720.github.io/Blog/vue-vuecli-init/index.html">[Vue]使用Vue CLI建立專案</a></p>
<h2 id="component">加入component</h2>
<p>在已建立好的專案中尋找src資料夾，並在src目錄下新增views目錄<br>
<img src="http://localhost:2368/content/images/2020/11/1-1.png" alt="[Vue]將Vue-Router加入到專案中"><br>
在views目錄中放入想要進行切換的component，這邊以Home.vue和About.vue進行示範<br>
<img src="http://localhost:2368/content/images/2020/11/2-1.png" alt="[Vue]將Vue-Router加入到專案中"><br>
<strong>Home.vue</strong></p>
<pre><code class="language-htmlmixed">&lt;template&gt;
  &lt;div class=&quot;home&quot;&gt;
    &lt;h1&gt;Home page&lt;/h1&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {

}
&lt;/script&gt;

</code></pre>
<p><strong>About.vue</strong></p>
<pre><code class="language-htmlmixed">&lt;template&gt;
  &lt;div class=&quot;about&quot;&gt;
    &lt;h1&gt;About page&lt;/h1&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {

}
&lt;/script&gt;

</code></pre>
<h2 id>建立路由目錄與檔案</h2>
<p>接著在src目錄下新增router資料夾，並新增index.js檔案<br>
<img src="http://localhost:2368/content/images/2020/11/3-1.png" alt="[Vue]將Vue-Router加入到專案中"><br>
在檔案中可自由新增或刪除component，並配置component對應的路由</p>
<p><strong>index.js</strong></p>
<pre><code class="language-javascript">import Vue from 'vue'
import VueRouter from 'vue-router'

//這裡可以自行import需要的component
import Home from '../views/Home.vue'
import About from '../views/About.vue'

Vue.use(VueRouter)

//建立路由routes
const routes = [
    {
        path: '/',
        component: Home
    },
    {
        path: '/About',
        component: About
    }
]

//建立Vue-Router的instance，並將routes的配置帶入
const router = new VueRouter({
    mode: 'hash',
    routes
})
//匯出成模組給Vue使用
export default router

</code></pre>
<h2 id>匯入路由</h2>
<p><img src="http://localhost:2368/content/images/2020/11/4-1.png" alt="[Vue]將Vue-Router加入到專案中"><br>
在<code>main.js</code>中加入以下指令載入router模組</p>
<pre><code class="language-javascript">import router from './router'
</code></pre>
<p>並在new Vue中加入router</p>
<pre><code class="language-javascript">new Vue({
  router,
  render: h =&gt; h(App)
}).$mount('#app')
</code></pre>
<p><strong>main.js</strong></p>
<pre><code class="language-javascript">import Vue from 'vue'
import App from './App.vue'
import router from './router'

Vue.config.productionTip = false

new Vue({
  router,
  render: h =&gt; h(App)
}).$mount('#app')

</code></pre>
<h2 id>加入路由連結</h2>
<p>在<code>App.vue</code>中加入Home和About的連結<br>
<img src="http://localhost:2368/content/images/2020/11/5.png" alt="[Vue]將Vue-Router加入到專案中"></p>
<pre><code class="language-javascript">&lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt;|
&lt;router-link to=&quot;/About&quot;&gt;About&lt;/router-link&gt;
&lt;router-view&gt;&lt;/router-view&gt;
</code></pre>
<p><strong>App.vue</strong></p>
<pre><code class="language-htmlmixed">&lt;template&gt;
  &lt;v-app&gt;
    &lt;v-main&gt;
      &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt;|
      &lt;router-link to=&quot;/About&quot;&gt;About&lt;/router-link&gt;
      &lt;router-view&gt;&lt;/router-view&gt;
    &lt;/v-main&gt;
  &lt;/v-app&gt;
&lt;/template&gt;

&lt;script&gt;

export default {
  name: 'App',

  components: {
  },

  data: () =&gt; ({
    //
  }),
};
&lt;/script&gt;
</code></pre>
<p>到這裡我們已經建立好路由了，接著我們使用開發者模式查看成果</p>
<h2 id>啟動開發者模式</h2>
<p>在終端機輸入命令啟動開發者模式</p>
<pre><code class="language-shell">npm run serve
</code></pre>
<p><img src="http://localhost:2368/content/images/2020/11/6.png" alt="[Vue]將Vue-Router加入到專案中"><br>
依照指示在瀏覽器輸入網址</p>
<h2 id>完成</h2>
<p>現在已可使用連結切換component!<br>
<img src="http://localhost:2368/content/images/2020/11/7.png" alt="[Vue]將Vue-Router加入到專案中"><br>
<img src="http://localhost:2368/content/images/2020/11/8.png" alt="[Vue]將Vue-Router加入到專案中"></p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[[Vue]Vuetify安裝與使用]]></title><description><![CDATA[Vuetify是一個Vue的UI框架，有許多精美和現成的組件可讓我們快速進行網頁排版及呈現，由於這篇文章撰寫時vuetify尚未支援Vue3，所以本篇文章以Vue2為例，示範如何將vuetify加入到Vue2專案中]]></description><link>http://localhost:2368/vue-vuetify-init/</link><guid isPermaLink="false">5fa82780420dbd31a087d3d1</guid><category><![CDATA[Vue]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Sun, 08 Nov 2020 17:18:40 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/11/vue.jpg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2020/11/vue.jpg" alt="[Vue]Vuetify安裝與使用"><p>Vuetify是一個Vue的UI框架，有許多精美和現成的組件可讓我們快速進行網頁排版及呈現，由於這篇文章撰寫時vuetify尚未支援Vue3，所以本篇文章以Vue2為例，示範如何將vuetify加入到Vue2專案中</p><!--kg-card-begin: markdown--><h2 id>環境</h2>
<ul>
<li>Windows10 x64 2004</li>
<li>Node.js - 6.12.1</li>
<li>Vue - @vue/cli 4.5.8</li>
<li>vue-cli-plugin-vuetify@2.0.7</li>
</ul>
<h2 id="vue">建立Vue專案</h2>
<p>在使用Vuetify之前必須先建立Vue專案，建立專案的方法請參考<a href="https://vincent87720.github.io/Blog/vue-vuecli-init/index.html">[Vue]使用Vue CLI建立專案</a></p>
<h2 id="vuetify">將Vuetify加入到專案</h2>
<p>切換到專案根目錄，並開啟終端機輸入指令，將Vuetify加入到專案</p>
<pre><code class="language-shell">vue add vuetify
</code></pre>
<p><img src="http://localhost:2368/content/images/2020/11/1.png" alt="[Vue]Vuetify安裝與使用"><br>
選擇<code>Default (recommended)</code><br>
<img src="http://localhost:2368/content/images/2020/11/2.png" alt="[Vue]Vuetify安裝與使用"><br>
安裝完成後在終端機輸入指令啟動開發者模式</p>
<pre><code class="language-shell">npm run serve
</code></pre>
<p><img src="http://localhost:2368/content/images/2020/11/3.png" alt="[Vue]Vuetify安裝與使用"><br>
成功啟動後會顯示網址，在瀏覽器網址列輸入網址即可瀏覽目前專案的狀態<br>
在瀏覽器輸入網址執行後，若出現以下畫面代表安裝成功<br>
<img src="http://localhost:2368/content/images/2020/11/4.png" alt="[Vue]Vuetify安裝與使用"></p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[[Vue]使用Vue CLI建立專案]]></title><description><![CDATA[在之前的課堂裡，我們都是直接開一個html檔案然後把vue寫在裡頭，這次助教介紹了Vue CLI，Vue CLI是一個官方出的工具，可以直接開一個測試用的伺服器，讓開發更方便，並且可以將程式碼打包，方便某些情況下的部屬]]></description><link>http://localhost:2368/vue-vuecli-init/</link><guid isPermaLink="false">5f986050c88dfb30b47715dc</guid><category><![CDATA[Vue]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Tue, 27 Oct 2020 18:13:25 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/10/vue.jpg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2020/10/vue.jpg" alt="[Vue]使用Vue CLI建立專案"><p>在之前的課堂裡，我們都是直接開一個html檔案然後把vue寫在裡頭，這次助教介紹了Vue CLI，Vue CLI是一個官方出的工具，可以直接開一個測試用的伺服器，讓開發更方便，並且可以將程式碼打包，方便某些情況下的部屬</p><!--kg-card-begin: markdown--><h2 id>環境</h2>
<ul>
<li>Windows10 x64 2004</li>
<li>Node.js - v12.19.0</li>
<li>Vue - @vue/cli 4.5.8</li>
</ul>
<h2 id="vuecli">下載並安裝VueCLI</h2>
<p>開啟終端機並輸入指令進行安裝</p>
<pre><code class="language-shell=cmd">npm install -g @vue/cli
</code></pre>
<p>輸入指令驗證VueCLI版本</p>
<pre><code class="language-shell=cmd">vue -V
</code></pre>
<h2 id="vue">建立Vue專案</h2>
<p><img src="http://localhost:2368/content/images/2020/10/1.png" alt="[Vue]使用Vue CLI建立專案"><br>
開啟終端機並輸入指令開啟建立專案程式，指令中的<code>&lt;name&gt;</code>使用自行定義的專案名稱替換掉</p>
<pre><code class="language-shell=cmd">vue create &lt;name&gt;
</code></pre>
<p><img src="http://localhost:2368/content/images/2020/10/2.png" alt="[Vue]使用Vue CLI建立專案"><br>
選擇要使用哪項模式建立專案，我們使用Manually select features進行自定義設定</p>
<p><img src="http://localhost:2368/content/images/2020/10/3.png" alt="[Vue]使用Vue CLI建立專案"><br>
預設會有三個選項已被勾選，為了防止一直報錯，我們按下方向鍵移動選項到Linter / Formatter並按下空白鍵，暫時將此選項取消勾選</p>
<p>接著移動到Choose Vue version並按下Enter鍵選擇Vue版本</p>
<p><img src="http://localhost:2368/content/images/2020/10/4.png" alt="[Vue]使用Vue CLI建立專案"><br>
這裡我們選擇使用Vue3的版本</p>
<p><img src="http://localhost:2368/content/images/2020/10/5.png" alt="[Vue]使用Vue CLI建立專案"><br>
接著選擇In dedicated config files選項</p>
<p><img src="http://localhost:2368/content/images/2020/10/6.png" alt="[Vue]使用Vue CLI建立專案"><br>
輸入y後按下Enter確認以上安裝資訊</p>
<p><img src="http://localhost:2368/content/images/2020/10/7.png" alt="[Vue]使用Vue CLI建立專案"><br>
若要將本次的選擇儲存成預設設定可填入名稱紀錄本次設定，下次在下vue create指令時就可以選擇此次的設定建立專案<br>
<img src="http://localhost:2368/content/images/2020/10/8.png" alt="[Vue]使用Vue CLI建立專案"></p>
<p><img src="http://localhost:2368/content/images/2020/10/9.png" alt="[Vue]使用Vue CLI建立專案"><br>
建立好專案後就可以在目錄內看到Vue的專案檔案了</p>
<h2 id="vue">設定Vue專案</h2>
<p>為了確保可以正確讀取assets的內容，我們需要修改@vue/cli-serve/lib/option.js內的參數或是以新增vue.config.js檔案的方式進行設定<br>
<a href="https://cli.vuejs.org/zh/config">Vue配置参考</a> <a href="http://wm.dyu.edu.tw/testweb/myWeb/">VueCli設定</a></p>
<ul>
<li>於Public資料夾下新增tools資料夾</li>
<li>在專案<strong>根目錄</strong>新增vue.config.js檔案，並輸入以下內容</li>
</ul>
<pre><code class="language-javascript">module.exports = {
    productionSourceMap:false,
    indexPath: 'index.html',
    assetsDir: 'tools',
    publicPath : ''
}
</code></pre>
<h2 id>啟動開發者模式伺服器</h2>
<p>開啟終端機並輸入指令</p>
<pre><code class="language-shell">npm run serve
</code></pre>
<p><img src="http://localhost:2368/content/images/2020/10/10.png" alt="[Vue]使用Vue CLI建立專案"><br>
出現Done就代表完成了，點選下方網址便可以使用瀏覽器觀看專案內網頁的狀態囉</p>
<h2 id>打包檔案</h2>
<p>當我們寫好網頁之後，我們可以使用build指令將檔案打包，便可以部屬到伺服器上了</p>
<pre><code class="language-shell=cmd">npm run build
</code></pre>
<p>執行之後在根目錄裡面出現dist資料夾就是已經打包好的檔案囉</p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[[C#]使用Npgsql連接到PostgreSQL server]]></title><description><![CDATA[<!--kg-card-begin: markdown--><h2 id>環境</h2>
<ul>
<li>Windows 10 x64</li>
<li>Visual Studio Community 2019 v16.2.2</li>
<li>Npgsql v4.1.4</li>
</ul>
<h2 id>安裝</h2>
<p>開啟visual studio後點選&quot;<strong>工具</strong>-&gt;<strong>NuGet套件管理員</strong>-&gt;<strong>管理方案的NuGet套件</strong>&quot;<br>
<img src="http://localhost:2368/content/images/2020/09/1.png" alt="1"><br>
點選Npgsql，勾選右方會執行到此套件的專案，再點選安裝<br>
<img src="http://localhost:2368/content/images/2020/09/2.png" alt="2"><br>
按確定進行安裝<br>
<img src="http://localhost:2368/content/images/2020/09/3.png" alt="3"></p>
<h2 id>建立連線</h2>
<p>設定好<code>host</code> <code>post</code> <code>username</code> <code>password</code> <code>database</code>等連線資訊後，使用<code>NpgsqlConnection</code>建立一個新連線，再使用Open()方法開啟連線</p>
<pre><code class="language-csharp">class Program
{
    
    static void Main(string[</code></pre>]]></description><link>http://localhost:2368/csharp-connect-to-postgresql/</link><guid isPermaLink="false">5f4ffba3a1fe94288c940dc2</guid><category><![CDATA[C#]]></category><category><![CDATA[NuGet]]></category><category><![CDATA[PostgreSQL]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Wed, 02 Sep 2020 20:21:06 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/09/dotNET.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><h2 id>環境</h2>
<ul>
<li>Windows 10 x64</li>
<li>Visual Studio Community 2019 v16.2.2</li>
<li>Npgsql v4.1.4</li>
</ul>
<h2 id>安裝</h2>
<img src="http://localhost:2368/content/images/2020/09/dotNET.png" alt="[C#]使用Npgsql連接到PostgreSQL server"><p>開啟visual studio後點選&quot;<strong>工具</strong>-&gt;<strong>NuGet套件管理員</strong>-&gt;<strong>管理方案的NuGet套件</strong>&quot;<br>
<img src="http://localhost:2368/content/images/2020/09/1.png" alt="[C#]使用Npgsql連接到PostgreSQL server"><br>
點選Npgsql，勾選右方會執行到此套件的專案，再點選安裝<br>
<img src="http://localhost:2368/content/images/2020/09/2.png" alt="[C#]使用Npgsql連接到PostgreSQL server"><br>
按確定進行安裝<br>
<img src="http://localhost:2368/content/images/2020/09/3.png" alt="[C#]使用Npgsql連接到PostgreSQL server"></p>
<h2 id>建立連線</h2>
<p>設定好<code>host</code> <code>post</code> <code>username</code> <code>password</code> <code>database</code>等連線資訊後，使用<code>NpgsqlConnection</code>建立一個新連線，再使用Open()方法開啟連線</p>
<pre><code class="language-csharp">class Program
{
    
    static void Main(string[] args)
    {
        string host = &quot;localhost&quot;;
        string port = &quot;5432&quot;;
        string username = &quot;postgres&quot;;
        string password = &quot;password&quot;;
        string database = &quot;postgis&quot;;
        string connStr = $&quot;Host={host};Port={port};Username={username};Password={password};Database={database};&quot;;
        using (NpgsqlConnection pgconn = new NpgsqlConnection(connStr))
        {
            pgconn.Open();
        }

    }
}
</code></pre>
<h2 id>執行查詢</h2>
<h3 id="npgsqldatareader">方法一：使用NpgsqlDataReader讀取資料</h3>
<p>執行查詢必須用到先前建立好的連線和即將要執行的查詢式</p>
<pre><code class="language-csharp">class Program
{
    static void Main(string[] args)
    {
        ExecuteQuery(&quot;SELECT id,x,y FROM users;&quot;);
    }
    
    public static void ExecuteQuery(string sqlstr)
    {
        using (var pgconn = new NpgsqlConnection(connStr))
        {
            pgconn.Open();
            using (var cmd = new NpgsqlCommand(sqlstr, pgconn))
            {
                using (var reader = cmd.ExecuteReader())//使用NpgsqlDataReader讀取資料
                {
                    while (reader.Read())//讀取下一列直到沒有數值
                    {
                        Console.Write(reader.GetInt32(0));//0代表該列第0行的值，也就是對應到查詢式中的id
                        Console.Write(reader.GetDouble(1));//1代表該列第1行的值，也就是對應到查詢式中的x
                        Console.WriteLine(reader.GetDouble(2));//2代表該列第2行的值，也就是對應到查詢式中的y
                    }
                }
            }
        }
    }
    private static string host = &quot;localhost&quot;;
    private static string port = &quot;5432&quot;;
    private static string username = &quot;postgres&quot;;
    private static string password = &quot;password&quot;;
    private static string database = &quot;postgis&quot;;
    private static string connStr = $&quot;Host={host};Port={port};Username={username};Password={password};Database={database};&quot;;
}
</code></pre>
<h3 id="npgsqldataadapterdatatable">方法二：使用NpgsqlDataAdapter將資料放入DataTable</h3>
<pre><code class="language-csharp">class Program
{
    static void Main(string[] args)
    {
        DataTable dt = ExecuteQuery(&quot;SELECT id,x,y FROM sptable;&quot;);

        foreach (DataRow row in dt.Rows)
        {
            Console.WriteLine(&quot;{0} {1} {2}&quot;, row[0], row[1], row[2]);//輸出該行的0,1,2個值，分別為id,x,y的值
        }
    }
    public static DataTable ExecuteQuery(string sqlstr)
    {
        using (NpgsqlConnection pgconn = new NpgsqlConnection(connStr))
        {
            pgconn.Open();

            DataTable dt = new DataTable();//建立一個DataTable

            try
            {
                using (NpgsqlDataAdapter sqladap = new NpgsqlDataAdapter(sqlstr, pgconn))
                {
                    sqladap.Fill(dt);//使用NpgsqlDataAdapter將資料放入DataTable中
                }
                return dt;//返回DataTable
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.ToString());
                return dt;
            }
        }
    }
    private static string host = &quot;localhost&quot;;
    private static string port = &quot;5432&quot;;
    private static string username = &quot;postgres&quot;;
    private static string password = &quot;password&quot;;
    private static string database = &quot;postgis&quot;;
    private static string connStr = $&quot;Host={host};Port={port};Username={username};Password={password};Database={database};&quot;;
}
</code></pre>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[[Golang]使用筆畫排序中文字]]></title><description><![CDATA[有次嘗試要使用筆劃排序中文姓名時，直接使用sort包進行排序，但發現結果並不是照著筆劃排序，查了點資料發現原來和UTF-8、Big5兩種編碼有極大的關係]]></description><link>http://localhost:2368/golang-sort-traditionalchinese/</link><guid isPermaLink="false">5f4e5a4978355806f01eea76</guid><category><![CDATA[golang]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Tue, 01 Sep 2020 14:33:48 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/09/golang-long.jpeg" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><img src="http://localhost:2368/content/images/2020/09/golang-long.jpeg" alt="[Golang]使用筆畫排序中文字"><p>有次嘗試要使用筆劃排序中文姓名時，直接使用sort包進行排序，但發現結果並不是照著筆劃排序，查了點資料發現原來和UTF-8、Big5兩種編碼有極大的關係</p>
<h2 id>環境</h2>
<ul>
<li>Windows 10 x64</li>
<li>go 1.15</li>
<li>golang.org/x/text v0.3.3</li>
</ul>
<h2 id="utf8big5">UTF-8和Big5的排序</h2>
<h3 id="big5">Big5</h3>
<p>從全字庫查詢到Big5的編碼原則</p>
<blockquote>
<p>以國家標準CNS11643及國際標準ISO10646漢字集為字源範圍，並依CNS11643之序編碼。</p>
</blockquote>
<p>而CNS11643的字碼編排原則又是如何呢?以下是定義</p>
<blockquote>
<p>依<strong>先筆畫後部首</strong>排列順序編碼。 說明： 每一字面均以文字總筆畫數為首序、部首為次序、筆順為末序編訂字碼，使用者只需以書寫之實際筆畫數即可查尋到國標碼。</p>
</blockquote>
<p>所以我們可以得知Big5以&quot;<strong>筆畫-&gt;部首-&gt;筆順</strong>&quot;為排列順序</p>
<h3 id="utf8">UTF-8</h3>
<p>而全字庫裡對於UTF-8的說明如下</p>
<blockquote>
<p>在I區的中日韓漢字部份，最當初進行編碼時，因各國漢字型體不盡相同，必須先進行認同(unify)整理工作，SC2/WG2因此邀集有關各國指派專家組成CJK/JRG(中日韓聯合研究工作組，即IRG前身)，進行字集的總整理。CJK/JRG歷經五次會議完成此項艱鉅工作，所整理的「中日韓認同表意文字」(CJK Unified Ideographs)參考了我國75年版CNS 11643之第1、2、14字面(T欄)，大陸的GB 2312、GB 12345、GB 7589、GB 17590、GB 8565(G欄)，日本的JIS X 0208、JIS X 0212(J欄)及南韓的KS C 5601、KSC 5667(K欄)等標準字符集，可說已包含這四地所常用的字。其字序主要是參考康熙字典、大漢和詞典、漢語大詞典及大字源字典，以<strong>先部首後筆劃</strong>的順序排列。</p>
</blockquote>
<p>所以我們可以得知UTF-8以&quot;<strong>部首-&gt;筆畫</strong>&quot;為排列順序</p>
<h2 id="golang">Golang的預設編碼</h2>
<p>golang預設使用UTF-8作為編碼格式，所以若直接使用sort包進行排序得出的結果會是依照先部首後筆畫的順序排序</p>
<h2 id="big5">轉為Big5排序</h2>
<p>若想得到以先筆畫後部首的方式排序，其中一個方法是將預設的UTF-8轉為Big5，使用Big5排序過後依照需求再轉換回UTF-8</p>
<h2 id>程式碼</h2>
<p>以&quot;<strong>毛隆青,劉雅君,陳嘉鴻,王育如,郭苡良,楊宗穎,李玉全,劉玉合,姚昶民,林欣麟</strong>&quot;十個姓名作為測試資料輸入，結果應為[<strong>毛隆青 王育如 李玉全 林欣麟 姚昶民 郭苡良 陳嘉鴻 楊宗穎 劉玉合 劉雅君</strong>]</p>
<p>此處須注意若筆劃數量相同，則會比對完部首後再比對下一個字，例如:<br>
<strong>毛隆青</strong>和<strong>王育如</strong>姓氏都是四劃，但是比對過筆劃後結果是'<strong>毛</strong>'先於'<strong>王</strong>'所以'<strong>毛</strong>'才會排在'<strong>王</strong>'前面</p>
<p><strong>main.go</strong></p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;sort&quot;

	&quot;golang.org/x/text/encoding/traditionalchinese&quot;
	&quot;golang.org/x/text/transform&quot;
)

func main() {

	s := []string{&quot;毛隆青&quot;, &quot;劉雅君&quot;, &quot;陳嘉鴻&quot;, &quot;王育如&quot;, &quot;郭苡良&quot;, &quot;楊宗穎&quot;, &quot;李玉全&quot;, &quot;劉玉合&quot;, &quot;姚昶民&quot;, &quot;林欣麟&quot;}

	s1 := sortByStroke(s)
	fmt.Println(s1)
}

func sortByStroke(input []string) (output []string) {
	output = make([]string, 0)
    
	//建立Encoder和Decoder
	utf8ToBig5 := traditionalchinese.Big5.NewEncoder()
	big5ToUtf8 := traditionalchinese.Big5.NewDecoder()

	//將UTF-8轉換為Big5
	for index := range input {
		big5, _, _ := transform.String(utf8ToBig5, input[index])
		input[index] = big5
	}

	//使用轉換成Big5的編碼進行排序
	sort.Strings(input)

	//將排序過後的Big5碼轉回UTF-8並放入output slice
	for _, value := range input {
		utf8, _, _ := transform.String(big5ToUtf8, value)
		output = append(output, utf8)
	}

	return output
}
</code></pre>
<pre><code>D:\&gt;go run main
[毛隆青 王育如 李玉全 林欣麟 姚昶民 郭苡良 陳嘉鴻 楊宗穎 劉玉合 劉雅君]
</code></pre>
<h2 id>參考資料</h2>
<p><a href="https://www.cns11643.gov.tw/pageView.jsp?ID=9">全字庫-中文碼介紹</a></p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[[GolangPackage] 使用lnx/walk建立圖形化介面]]></title><description><![CDATA[golang 普遍使用CLI作為使用者介面，但因為需要做一個程式給不常使用指令的人使用，所以使用lxn/walk建立圖形化使用者介面，lxn/walk可以滿足視窗的大部分需求，適用於建立一些基本的圖形化介面]]></description><link>http://localhost:2368/golang-package-walk/</link><guid isPermaLink="false">5f4809f66c8c391358537596</guid><category><![CDATA[golang]]></category><category><![CDATA[golangPackage]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Thu, 27 Aug 2020 19:48:31 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/08/golang-long.jpeg" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><img src="http://localhost:2368/content/images/2020/08/golang-long.jpeg" alt="[GolangPackage] 使用lnx/walk建立圖形化介面"><p>golang 普遍使用CLI作為使用者介面，但因為需要做一個程式給不常使用指令的人使用，所以使用lxn/walk建立圖形化使用者介面，lxn/walk可以滿足視窗的大部分需求，適用於建立一些基本的圖形化介面</p>
<h2 id>環境</h2>
<ul>
<li>Windows 10 x64</li>
<li>go 1.15</li>
<li>github.com/lxn/walk v0.0.0-20200806153934-8721e9bc9ff7</li>
<li>github.com/akavel/rsrc v0.9.0</li>
</ul>
<h2 id>安裝</h2>
<p>要將程式包裝成可執行檔需要兩個package，分別是lxn/walk和akavel/rsrc<br>
lxn/walk用來建立圖形化介面<br>
akavel/rsrc用來將資源嵌入可執行檔<br>
使用指令安裝lxn/walk和akavel/rsrc</p>
<pre><code>go get github.com/lxn/walk
go get github.com/akavel/rsrc
</code></pre>
<h2 id>結構</h2>
<p>在lxn/walk下包含了declarative sub package、範例檔和各種元件的檔案</p>
<pre><code>－github.com
    |－lxn
        |－walk
            |－declarative
            |－examples
            |...其他檔案
</code></pre>
<p>以examples下的action範例裡的一小段程式碼為例</p>
<pre><code>PushButton{
	AssignTo: &amp;toggleSpecialModePB,
	Text:     &quot;Enable Special Mode&quot;,
	OnClicked: func() {
		isSpecialMode.SetSatisfied(!isSpecialMode.Satisfied())

		if isSpecialMode.Satisfied() {
			toggleSpecialModePB.SetText(&quot;Disable Special Mode&quot;)
		} else {
			toggleSpecialModePB.SetText(&quot;Enable Special Mode&quot;)
		}
	},
	Accessibility: Accessibility{
		Help: &quot;Toggles special mode&quot;,
	},
},
</code></pre>
<p>很好奇PushButton裡面的這些參數到底是哪裡來的對吧<br>
讓我們看看declarative目錄下的pushbutton.go檔案</p>
<p><strong>pushbutton.go</strong></p>
<pre><code>package declarative

import (
	&quot;github.com/lxn/walk&quot;
)

type PushButton struct {
	// Window

	Accessibility      Accessibility
	Background         Brush
	ContextMenuItems   []MenuItem
	DoubleBuffering    bool
	Enabled            Property
	Font               Font
	MaxSize            Size
	MinSize            Size
	Name               string
	OnBoundsChanged    walk.EventHandler
	OnKeyDown          walk.KeyEventHandler
	OnKeyPress         walk.KeyEventHandler
	OnKeyUp            walk.KeyEventHandler
	OnMouseDown        walk.MouseEventHandler
	OnMouseMove        walk.MouseEventHandler
	OnMouseUp          walk.MouseEventHandler
	OnSizeChanged      walk.EventHandler
	Persistent         bool
	RightToLeftReading bool
	ToolTipText        Property
	Visible            Property

	// Widget

	Alignment          Alignment2D
	AlwaysConsumeSpace bool
	Column             int
	ColumnSpan         int
	GraphicsEffects    []walk.WidgetGraphicsEffect
	Row                int
	RowSpan            int
	StretchFactor      int

	// Button

	Image     Property
	OnClicked walk.EventHandler
	Text      Property

	// PushButton

	AssignTo       **walk.PushButton
	ImageAboveText bool
}
</code></pre>
<p>這邊清楚的定義了哪些元件可以用哪些參數，只要照著結構裡定義的屬性名稱和型別給予對應的數值就可以了</p>
<h2 id>建置與執行</h2>
<p>要執行圖形化介面無法直接使用go run執行<br>
必須在相同目錄下新增.manifest檔案並使用go build建置產生可執行檔<br>
再啟動可執行檔執行<br>
我們使用examples下的clipboard作為範例</p>
<p><strong>clipboard.go</strong></p>
<pre><code>// Copyright 2013 The Walk Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	&quot;log&quot;
)

import (
	&quot;github.com/lxn/walk&quot;
	. &quot;github.com/lxn/walk/declarative&quot;
)

func main() {
	var te *walk.TextEdit

	if _, err := (MainWindow{
		Title:   &quot;Walk Clipboard Example&quot;,
		MinSize: Size{300, 200},
		Layout:  VBox{},
		Children: []Widget{
			PushButton{
				Text: &quot;Copy&quot;,
				OnClicked: func() {
					if err := walk.Clipboard().SetText(te.Text()); err != nil {
						log.Print(&quot;Copy: &quot;, err)
					}
				},
			},
			PushButton{
				Text: &quot;Paste&quot;,
				OnClicked: func() {
					if text, err := walk.Clipboard().Text(); err != nil {
						log.Print(&quot;Paste: &quot;, err)
					} else {
						te.SetText(text)
					}
				},
			},
			TextEdit{
				AssignTo: &amp;te,
			},
		},
	}).Run(); err != nil {
		log.Fatal(err)
	}
}
</code></pre>
<p><strong>test.manifest</strong></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
&lt;assembly xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot; manifestVersion=&quot;1.0&quot;&gt;
    &lt;assemblyIdentity version=&quot;1.0.0.0&quot; processorArchitecture=&quot;*&quot; name=&quot;SomeFunkyNameHere&quot; type=&quot;win32&quot;/&gt;
    &lt;dependency&gt;
        &lt;dependentAssembly&gt;
            &lt;assemblyIdentity type=&quot;win32&quot; name=&quot;Microsoft.Windows.Common-Controls&quot; version=&quot;6.0.0.0&quot; processorArchitecture=&quot;*&quot; publicKeyToken=&quot;6595b64144ccf1df&quot; language=&quot;*&quot;/&gt;
        &lt;/dependentAssembly&gt;
    &lt;/dependency&gt;
    &lt;application xmlns=&quot;urn:schemas-microsoft-com:asm.v3&quot;&gt;
        &lt;windowsSettings&gt;
            &lt;dpiAwareness xmlns=&quot;http://schemas.microsoft.com/SMI/2016/WindowsSettings&quot;&gt;PerMonitorV2, PerMonitor&lt;/dpiAwareness&gt;
            &lt;dpiAware xmlns=&quot;http://schemas.microsoft.com/SMI/2005/WindowsSettings&quot;&gt;True&lt;/dpiAware&gt;
        &lt;/windowsSettings&gt;
    &lt;/application&gt;
&lt;/assembly&gt;
</code></pre>
<p>建立一個目錄並在目錄底下放置clipboard.go和test.manifest兩個檔案</p>
<pre><code>－walktest
    |－clipboard.go
    |－test.manifest
</code></pre>
<p>第一次要使用指令產生.syso檔</p>
<pre><code>rsrc -manifest test.manifest -o rsrc.syso
</code></pre>
<p>再輸入指令建置可執行檔</p>
<pre><code>go build
</code></pre>
<p>運行可執行檔就會出現圖形化介面了</p>
<pre><code>walktest.exe
</code></pre>
<p><img src="http://localhost:2368/golang-package-walk/assets/1.png" alt="[GolangPackage] 使用lnx/walk建立圖形化介面"></p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[[Qt]Qt的鍵盤與滑鼠點擊事件]]></title><description><![CDATA[Qt的鍵盤與滑鼠點擊事件]]></description><link>http://localhost:2368/qt-key-mouse-press-event/</link><guid isPermaLink="false">5ee33b6118d9a726c4d13dcf</guid><category><![CDATA[Qt]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Fri, 12 Jun 2020 14:29:28 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/06/DarkCyan.jpg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2020/06/DarkCyan.jpg" alt="[Qt]Qt的鍵盤與滑鼠點擊事件"><p></p><h2 id="-">環境</h2><p>Qt 5.14.1<br>Qt Creator 4.11.1</p><hr><h2 id="--1">滑鼠點擊事件</h2><p>引用QMouseEvent標頭檔</p><!--kg-card-begin: markdown--><pre><code>#include &lt;QMouseEvent&gt;</code></pre>
<!--kg-card-end: markdown--><p>在protected裡定義滑鼠觸發事件</p><!--kg-card-begin: markdown--><pre><code>protected:
    void mousePressEvent(QMouseEvent * event);</code></pre>
<!--kg-card-end: markdown--><p>新增具體觸發事件</p><!--kg-card-begin: markdown--><pre><code>void MainWindow::mousePressEvent(QMouseEvent * e)
{
    //獲取座標
    qDebug() &lt;&lt;&quot;(&quot;&lt;&lt; e-&gt;x() &lt;&lt; &quot;,&quot; &lt;&lt; e-&gt;y()&lt;&lt;&quot;)&quot;;

    if(e-&gt;button() == Qt::LeftButton)
    {
        qDebug() &lt;&lt; &quot;左鍵&quot; ;
    }
    else if(e-&gt;button() == Qt::RightButton)
    {
        qDebug() &lt;&lt; &quot;右鍵&quot; ;
    }
}</code></pre>
<!--kg-card-end: markdown--><p>要使用qDebug()輸出時必須增加#include&lt;QDebug&gt;引用QDebug標頭檔</p><hr><h2 id="--2">鍵盤點擊事件</h2><p>在protected裡定義滑鼠觸發事件</p><!--kg-card-begin: markdown--><pre><code>protected:
    void keyPressEvent(QKeyEvent * event);</code></pre>
<!--kg-card-end: markdown--><p>新增鍵盤觸發事件</p><!--kg-card-begin: markdown--><pre><code>void MainWindow::keyPressEvent(QKeyEvent * event)
{
    switch (event-&gt;key())
    {
        case Qt::Key_Alt:{
                qDebug() &lt;&lt; &quot;Alt&quot;;
            break;
        }
        default:{
                qDebug() &lt;&lt; event-&gt;key();
            break;
        }
    }
}</code></pre>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[[GolangPackage]指定golang執行檔檔案屬性]]></title><description><![CDATA[GoVersionInfo package可在生成執行檔時指定執行檔縮圖及檔案屬性，檔案描述、檔案類型、版本等參數皆可指定]]></description><link>http://localhost:2368/golang-package-goversioninfo/</link><guid isPermaLink="false">5ec6a6b6986e6527cc1d24c9</guid><category><![CDATA[golangPackage]]></category><category><![CDATA[golang]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Thu, 21 May 2020 17:34:18 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/05/golang-long.jpeg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2020/05/golang-long.jpeg" alt="[GolangPackage]指定golang執行檔檔案屬性"><p>GoVersionInfo package可在生成執行檔時指定執行檔縮圖及檔案屬性，檔案描述、檔案類型、版本等參數皆可指定</p><hr><h2 id="-">安裝<br></h2><h3 id="-package">使用指令安裝package</h3><!--kg-card-begin: markdown--><pre><code>go get github.com/josephspurrier/goversioninfo/cmd/goversioninfo</code></pre>
<!--kg-card-end: markdown--><h3 id="--1">產生可執行檔</h3><p>-0 bin/goversioninfo.exe代表要將產生出來的可執行檔放在bin目錄裡，並將檔名命名為goversioninfo.exe<br>空一格後面接github.com/josephspurrier/goversioninfo/cmd/goversioninfo代表要以這個package為目標產生可執行檔</p><!--kg-card-begin: markdown--><pre><code>go build -o bin/goversioninfo.exe github.com/josephspurrier/goversioninfo/cmd/goversioninfo</code></pre>
<!--kg-card-end: markdown--><hr><h2 id="--2">設定<br></h2><h3 id="-go-generate-">設定go generate註釋</h3><p>將//go:generate goversioninfo加入到程式碼的最頂端，往後在執行go generate命令時才能夠被搜尋到</p><!--kg-card-begin: markdown--><pre><code>//go:generate goversioninfo

package main

import &quot;fmt&quot;

func main() {
    fmt.Println(&quot;Hello world&quot;)
}
</code></pre>
<!--kg-card-end: markdown--><h3 id="-versioninfo-json-">設定versioninfo.json檔案</h3><p>在github.com\josephspurrier\goversioninfo\testdata\resource內有一個檔名為versioninfo的json檔，將其複製並放置於要產生執行檔的程式碼的目錄中</p><p>resource資料夾內有icon和goversioninfo.exe.manifest兩個檔案，等等在設定versioninfo時會用到</p><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2020/05/---2020-05-22-012503.png" class="kg-image" alt="[GolangPackage]指定golang執行檔檔案屬性"></figure><h3 id="-versioninfo-json--1">指定versioninfo.json檔案參數</h3><p>將IconPath和ManifestPath的路徑指定為可執行檔圖示的路徑和Manifest檔案的路徑</p><!--kg-card-begin: markdown--><pre><code>{
    &quot;FixedFileInfo&quot;: {
        &quot;FileVersion&quot;: {
            &quot;Major&quot;: 1,
            &quot;Minor&quot;: 0,
            &quot;Patch&quot;: 0,
            &quot;Build&quot;: 0
        },
        &quot;ProductVersion&quot;: {
            &quot;Major&quot;: 1,
            &quot;Minor&quot;: 0,
            &quot;Patch&quot;: 0,
            &quot;Build&quot;: 0
        },
        &quot;FileFlagsMask&quot;: &quot;3f&quot;,
        &quot;FileFlags &quot;: &quot;00&quot;,
        &quot;FileOS&quot;: &quot;040004&quot;,
        &quot;FileType&quot;: &quot;01&quot;,
        &quot;FileSubType&quot;: &quot;00&quot;
    },
    &quot;StringFileInfo&quot;: {
        &quot;Comments&quot;: &quot;Test file.&quot;,
        &quot;CompanyName&quot;: &quot;josephspurrier&quot;,
        &quot;FileDescription&quot;: &quot;This is a hello world file.&quot;,
        &quot;FileVersion&quot;: &quot;v1.0.0.0&quot;,
        &quot;InternalName&quot;: &quot;goversioninfo.exe&quot;,
        &quot;LegalCopyright&quot;: &quot;Copyright (c) 2019 Joseph Spurrier&quot;,
        &quot;LegalTrademarks&quot;: &quot;&quot;,
        &quot;OriginalFilename&quot;: &quot;main.go&quot;,
        &quot;PrivateBuild&quot;: &quot;&quot;,
        &quot;ProductName&quot;: &quot;goversioninfo&quot;,
        &quot;ProductVersion&quot;: &quot;v1.0.0.0&quot;,
        &quot;SpecialBuild&quot;: &quot;&quot;
    },
    &quot;VarFileInfo&quot;: {
        &quot;Translation&quot;: {
            &quot;LangID&quot;: &quot;0409&quot;,
            &quot;CharsetID&quot;: &quot;04B0&quot;
        }
    },
    &quot;IconPath&quot;: &quot;resource/icon.ico&quot;,
    &quot;ManifestPath&quot;: &quot;resource/goversioninfo.exe.manifest&quot;
}</code></pre>
<!--kg-card-end: markdown--><h3 id="-syso-">產生syso檔</h3><p>輸入go generate指令產生resource.syso檔案，若不在同個目錄內可指定package路徑，例如主程式在D:\Project\Go\src\goinfotest，若當前位置在目錄內直接下go generate即可，若不在目錄內則要輸入go generate+從src目錄後開始算的package路徑(go generate goinfotest)產生syso檔</p><!--kg-card-begin: markdown--><pre><code>go generate
go generate your\package\route</code></pre>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2020/05/---2020-05-22-013035.png" class="kg-image" alt="[GolangPackage]指定golang執行檔檔案屬性"></figure><h3 id="--3">產生可執行檔</h3><p>使用go build產生可執行檔，亦可使用"go build -o 目的路徑與檔名 +package路徑"產生可執行檔</p><!--kg-card-begin: markdown--><pre><code>go build
go build -o output\route your\package\route</code></pre>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2020/05/---2020-05-22-013343.png" class="kg-image" alt="[GolangPackage]指定golang執行檔檔案屬性"></figure>]]></content:encoded></item><item><title><![CDATA[[C++]陣列與指標的位址]]></title><description><![CDATA[C++陣列與指標的位址]]></description><link>http://localhost:2368/cpp-array-pointer-address/</link><guid isPermaLink="false">5e71c4046286de0ce0c06f09</guid><category><![CDATA[C++]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Wed, 18 Mar 2020 07:43:05 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/03/C--.jpg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2020/03/C--.jpg" alt="[C++]陣列與指標的位址"><p>首先宣告名稱為arr大小為10的int陣列，接著分別輸出arr、&amp;arr[0]和&amp;arr</p><!--kg-card-begin: markdown--><pre><code>#include &lt;iostream&gt;

int main()
{
    int arr[10] = { 0 };

    std::cout &lt;&lt; &quot;arr\t&quot; &lt;&lt; arr &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;&amp;arr[0]\t&quot; &lt;&lt; &amp;arr[0] &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;&amp;arr\t&quot; &lt;&lt; &amp;arr &lt;&lt; std::endl;
}</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>&gt;arr     006FFC80
&gt;&amp;arr[0] 006FFC80
&gt;&amp;arr    006FFC80</code></pre>
<!--kg-card-end: markdown--><p>我們可以看到直接輸出陣列變數時會出現陣列中第一個元素的位址</p><p>輸出&amp;arr[0]也會出現陣列中第一個元素的位址，其中arr[0]代表第零個元素，而將&amp;加在前面則代表取得其位址，也就是arr[0]的位址</p><p>2而&amp;arr代表輸出arr變數位址，其位址就是第零個元素的位址，也就等於arr[0]的位址，所以輸出的結果會與前兩個相同</p><p></p><p>這時我們宣告一個名稱為p的int指標，將arr的位址指派給它，並分別輸出p、&amp;p[0]和&amp;p</p><!--kg-card-begin: markdown--><pre><code>#include &lt;iostream&gt;

int main()
{
    int arr[10] = { 0 };

    std::cout &lt;&lt; &quot;arr\t&quot; &lt;&lt; arr &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;&amp;arr[0]\t&quot; &lt;&lt; &amp;arr[0] &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;&amp;arr\t&quot; &lt;&lt; &amp;arr &lt;&lt; std::endl;

    int* p = arr;
    std::cout &lt;&lt; &quot;p\t&quot; &lt;&lt; p &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;&amp;p[0]\t&quot; &lt;&lt; &amp;p[0] &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;&amp;p\t&quot; &lt;&lt; &amp;p &lt;&lt; std::endl;
}</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>&gt;p       006FFC80
&gt;&amp;p[0]   006FFC80
&gt;&amp;p      006FFC74</code></pre>
<!--kg-card-end: markdown--><p>這時p指標中儲存的是arr的位址，所以輸出的自然也就和arr的位址相同</p><p>&amp;p[0]指的是p[0]這個元素的位址，因為p指標是指向arr陣列的，所以當存取p[0]時會去尋找arr[0]，而自然其位址也就會等於arr[0]的位址</p><p>比較特別的是&amp;p，&amp;p代表取得p的位址，而因為p是指標，我們是取得p的位址，所以和arr的位址就不會是同一個了</p>]]></content:encoded></item></channel></rss>
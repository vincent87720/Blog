<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[柴魚筆記本]]></title><description><![CDATA[程式 • 軟體 • 攝影]]></description><link>http://localhost:2368/</link><image><url>http://localhost:2368/favicon.png</url><title>柴魚筆記本</title><link>http://localhost:2368/</link></image><generator>Ghost 3.1</generator><lastBuildDate>Wed, 18 Mar 2020 07:44:19 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[C++陣列與指標的位址]]></title><description><![CDATA[C++陣列與指標的位址]]></description><link>http://localhost:2368/cpp-array-pointer-address/</link><guid isPermaLink="false">5e71c4046286de0ce0c06f09</guid><category><![CDATA[C++]]></category><category><![CDATA[C++Basic]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Wed, 18 Mar 2020 07:43:05 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/03/C--.jpg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2020/03/C--.jpg" alt="C++陣列與指標的位址"><p>首先宣告名稱為arr大小為10的int陣列，接著分別輸出arr、&amp;arr[0]和&amp;arr</p><!--kg-card-begin: markdown--><pre><code>#include &lt;iostream&gt;

int main()
{
    int arr[10] = { 0 };

    std::cout &lt;&lt; &quot;arr\t&quot; &lt;&lt; arr &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;&amp;arr[0]\t&quot; &lt;&lt; &amp;arr[0] &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;&amp;arr\t&quot; &lt;&lt; &amp;arr &lt;&lt; std::endl;
}</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>&gt;arr     006FFC80
&gt;&amp;arr[0] 006FFC80
&gt;&amp;arr    006FFC80</code></pre>
<!--kg-card-end: markdown--><p>我們可以看到直接輸出陣列變數時會出現陣列中第一個元素的位址</p><p>輸出&amp;arr[0]也會出現陣列中第一個元素的位址，其中arr[0]代表第零個元素，而將&amp;加在前面則代表取得其位址，也就是arr[0]的位址</p><p>2而&amp;arr代表輸出arr變數位址，其位址就是第零個元素的位址，也就等於arr[0]的位址，所以輸出的結果會與前兩個相同</p><p></p><p>這時我們宣告一個名稱為p的int指標，將arr的位址指派給它，並分別輸出p、&amp;p[0]和&amp;p</p><!--kg-card-begin: markdown--><pre><code>#include &lt;iostream&gt;

int main()
{
    int arr[10] = { 0 };

    std::cout &lt;&lt; &quot;arr\t&quot; &lt;&lt; arr &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;&amp;arr[0]\t&quot; &lt;&lt; &amp;arr[0] &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;&amp;arr\t&quot; &lt;&lt; &amp;arr &lt;&lt; std::endl;

    int* p = arr;
    std::cout &lt;&lt; &quot;p\t&quot; &lt;&lt; p &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;&amp;p[0]\t&quot; &lt;&lt; &amp;p[0] &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;&amp;p\t&quot; &lt;&lt; &amp;p &lt;&lt; std::endl;
}</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>&gt;p       006FFC80
&gt;&amp;p[0]   006FFC80
&gt;&amp;p      006FFC74</code></pre>
<!--kg-card-end: markdown--><p>這時p指標中儲存的是arr的位址，所以輸出的自然也就和arr的位址相同</p><p>&amp;p[0]指的是p[0]這個元素的位址，因為p指標是指向arr陣列的，所以當存取p[0]時會去尋找arr[0]，而自然其位址也就會等於arr[0]的位址</p><p>比較特別的是&amp;p，&amp;p代表取得p的位址，而因為p是指標，我們是取得p的位址，所以和arr的位址就不會是同一個了</p>]]></content:encoded></item><item><title><![CDATA[開啟Clover時顯示錯誤訊息：Cannot install without ensuring the file system is read-write]]></title><description><![CDATA[在開啟Clover時會跳出"Cannot install without ensuring the file system is read-write"錯誤訊息]]></description><link>http://localhost:2368/clover-package-err/</link><guid isPermaLink="false">5e512e2257c9b119c4cb7261</guid><category><![CDATA[clover]]></category><category><![CDATA[hackintosh]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Sat, 22 Feb 2020 14:11:49 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/02/clover-1.png" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2020/02/errMsg.png" class="kg-image" alt="開啟Clover時顯示錯誤訊息：Cannot install without ensuring the file system is read-write"></figure><img src="http://localhost:2368/content/images/2020/02/clover-1.png" alt="開啟Clover時顯示錯誤訊息：Cannot install without ensuring the file system is read-write"><p></p><h2 id="-">版本</h2><p>OS：macOs Catalina  Version 10.15.3<br>Clover：Clover_v2.5k_r5104</p><hr><h2 id="--1">問題</h2><p>在開啟Clover時會跳出"Cannot install without ensuring the file system is read-write"錯誤訊息</p><hr><h2 id="--2">解決方法及步驟</h2><p>1.Click the Apple symbol in the Menu bar.<br>2.Click Restart…<br>3.Hold down Command-R to reboot into Recovery Mode.<br>4.Click Utilities.<br>5.Select Terminal.<br>6.Type csrutil disable.<br>7.Press Return or Enter on your keyboard.<br>8.Click the Apple symbol in the Menu bar.<br>9.Click Restart…</p><hr><h2 id="--3">參考資料</h2><figure class="kg-card kg-embed-card">
    <blockquote class="reddit-card">
      <a href="https://www.reddit.com/r/hackintosh/comments/d9pbhy/clover_cannot_install_wo_ensuring_file_system_is/?ref_source=embed&amp;ref=share">Clover - Cannot Install w/o Ensuring File System is Read/Write</a> from
      <a href="https://www.reddit.com/r/hackintosh/">hackintosh</a>
    </blockquote>
    <script async src="https://embed.redditmedia.com/widgets/platform.js" charset="UTF-8"></script>
</figure>]]></content:encoded></item><item><title><![CDATA[Golang channel簡介]]></title><description><![CDATA[在golang裡可使用channel在多個執行緒與主程式之間傳送資料，channel可設定不同型態的buffer，並指定緩衝區大小]]></description><link>http://localhost:2368/golang-channel/</link><guid isPermaLink="false">5e2ee3d2c847230f10934c35</guid><category><![CDATA[golang]]></category><category><![CDATA[golangBasic]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Mon, 27 Jan 2020 15:43:32 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/01/golang-long-2.jpeg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2020/01/golang-long-2.jpeg" alt="Golang channel簡介"><p></p><p>在golang裡可使用channel在多個執行緒與主程式之間傳送資料，channel可設定不同型態的buffer，並指定緩衝區大小</p><hr><h2 id="-channel">建立channel</h2><p>使用make配置空間，第一個參數使用chan指定為通道類型，後面接上channel的型態，第二個參數可加可不加，用來宣告buffer的大小</p><!--kg-card-begin: markdown--><pre><code>ch := make(chan int)
ch := make(chan int,5)</code></pre>
<!--kg-card-end: markdown--><p>須注意buffer的預設大小為零，若無指定buffer大小則發送方與接收方需同時準備好才可傳值，否則會造成deadlock(死結)</p><!--kg-card-begin: markdown--><pre><code>//OK(buffer為0)
ch := make(chan int)
defer close(ch)
go func(){
    ch &lt;- 7
}()

fmt.Println(&lt;-ch)

//ERROR(buffer為0)
ch := make(chan int)
defer close(ch)
ch &lt;- 7

fmt.Println(&lt;-ch)

//OK(buffer為1)
ch := make(chan int,1)
defer close(ch)
ch &lt;- 7

fmt.Println(&lt;-ch)</code></pre>
<!--kg-card-end: markdown--><hr><h2 id="-channel-">使用channel傳遞數值</h2><h3 id="-channel-1">傳入channel</h3><p>將箭頭由數值指向channel，代表將值傳入到channel內</p><!--kg-card-begin: markdown--><pre><code>ch &lt;- 7</code></pre>
<!--kg-card-end: markdown--><h3 id="-channel-2">傳出channel</h3><p>將箭頭由channel指向目的地，代表將數值由channel傳出</p><!--kg-card-begin: markdown--><pre><code>var result int
result &lt;- ch
fmt.Println(result)</code></pre>
<!--kg-card-end: markdown--><hr><h2 id="-goroutine-">等待所有goroutine結束</h2><p>有時會遇到明明寫好了goroutine，但在最後將要把數據輸出時卻沒出現任何數據，這時就有可能是因為執行緒尚未結束運算而主程式已經執行完輸出的作業了，所以輸出時不會得到channel傳來的任何資訊，當然也不會輸出任何東西</p><!--kg-card-begin: markdown--><pre><code>func foo(ch chan int, val int) {
    ch &lt;- val
}

func main() {
    ch := make(chan int, 5)
    for i := 0; i &lt; 5; i++ {
        foo(ch, i)
    }
    close(ch)

    for ele := range ch {
        fmt.Println(ele)
    }
}</code></pre>
<!--kg-card-end: markdown--><p>我們可以使用WaitGroup控制，等到所有執行緒都結束後再繼續往下執行</p><!--kg-card-begin: markdown--><pre><code>var wg sync.WaitGroup

func foo(ch chan int, val int) {
    defer wg.Done()
    ch &lt;- val
}

func main() {
    ch := make(chan int, 5)
    for i := 0; i &lt; 5; i++ {
        wg.Add(1)
        foo(ch, i)
    }
    wg.Wait()
    close(ch)

    for ele := range ch {
        fmt.Println(ele)
    }
}</code></pre>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[GolangPackage Excel的讀寫與操作]]></title><description><![CDATA[excelize是一個能夠讀寫excel的package，可讀入或寫入指定位置的資料及更改樣式，適用於批量產生excel檔案及資料處理]]></description><link>http://localhost:2368/golang-package-excelize/</link><guid isPermaLink="false">5e2d660c17169e27181beddf</guid><category><![CDATA[golang]]></category><category><![CDATA[golangPackage]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Sun, 26 Jan 2020 15:50:18 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/01/golang-long-1.jpeg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2020/01/golang-long-1.jpeg" alt="GolangPackage Excel的讀寫與操作"><p></p><p>excelize是一個能夠讀寫excel的package，可讀入或寫入指定位置的資料及更改樣式，適用於批量產生excel檔案及資料處理，須注意的是該package只支援.xlsx的檔案格式，尚不支援.xls的檔案處理</p><hr><h2 id="-">安裝</h2><p>使用指令安裝package</p><!--kg-card-begin: markdown--><pre><code>go get github.com/Luxurioust/excelize</code></pre>
<!--kg-card-end: markdown--><hr><h2 id="--1">檔案操作<br></h2><h3 id="--2">創建新檔</h3><!--kg-card-begin: markdown--><pre><code>xlsx := excelize.NewFile()</code></pre>
<!--kg-card-end: markdown--><h3 id="--3">開啟舊檔</h3><!--kg-card-begin: markdown--><pre><code>inputFilePath := &quot;D:\Project&quot;
xlsx, err := excelize.OpenFile(inputFilePath)
if err != nil {
	fmt.Println(&quot;\rERROR:&quot;, err)
}</code></pre>
<!--kg-card-end: markdown--><h3 id="--4">讀取內容</h3><p>將檔案內的資料讀入一個二維的字串slice</p><!--kg-card-begin: markdown--><pre><code>sheetName := &quot;Sheet1&quot;//指定要讀取的工作表名稱
xlsxRows, err = xlsx.GetRows(sheetName)
if err != nil {
	fmt.Println(&quot;\rERROR:&quot;,err)
}</code></pre>
<!--kg-card-end: markdown--><h3 id="--5">變更工作表名稱</h3><!--kg-card-begin: markdown--><pre><code>oldSheetName := &quot;Sheet1&quot;//指定目前工作表名稱
newSheetName := &quot;工作表&quot;//指定新的工作表名稱
xlsx.SetSheetName(oldSheetName, newSheetName)</code></pre>
<!--kg-card-end: markdown--><h3 id="--6">設定樣式</h3><p><strong>建立樣式</strong><br>呼叫函式時使用JSON格式填入所需的樣式參數</p><p>fill：設定儲存格網底</p><!--kg-card-begin: markdown--><table>
<thead>
<tr>
<th>fill</th>
<th>使用單一顏色填充</th>
<th>使用漸層填充</th>
</tr>
</thead>
<tbody>
<tr>
<td>typr</td>
<td>pattern</td>
<td>gradient</td>
</tr>
<tr>
<td>color</td>
<td>[&quot;#FFFFFF&quot;]</td>
<td>[&quot;#FFFFFF&quot;,&quot;#E0EBF5&quot;]</td>
</tr>
<tr>
<td>gradient</td>
<td>X</td>
<td>0:橫向<br>1:縱向<br>2:對角線向上<br>3:對角線向下<br>4:由對角線向內<br>5:由中心向外</td>
</tr>
<tr>
<td>pattern</td>
<td>0:無<br>1:實心<br>2:75%灰色<br>3:50%灰色<br>4:25%灰色<br>5:水平條紋<br>6:垂直條紋<br>7:反對角線條紋<br>8:對角線條紋<br>9:對角線斜紋<br>10:粗線對角線斜紋<br>11:細線水平條紋<br>12:細線垂直條紋<br>13:細線反對角線條紋<br>14:細線對角線條紋<br>15:細線水平斜紋<br>16:細線對角線斜紋<br>17:12.5%灰色<br>18:6.25%灰色</td>
<td>X</td>
</tr>
</tbody>
</table>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>//單一顏色填充
patternStyle, err := xlsx.NewStyle(`{&quot;fill&quot;:{&quot;type&quot;:&quot;pattern&quot;,&quot;color&quot;:[&quot;#EBF0F3&quot;],&quot;pattern&quot;:1}}`)
if err != nil {
	fmt.Println(&quot;\rERROR:&quot;,err)
}

//漸層填充
gradientStyle, err := f.NewStyle(`{&quot;fill&quot;:{&quot;type&quot;:&quot;gradient&quot;,&quot;color&quot;:[&quot;#FFFFFF&quot;,&quot;#E0EBF5&quot;],&quot;shading&quot;:1}}`)
if err != nil {
    fmt.Println(err)
}
</code></pre>
<!--kg-card-end: markdown--><p></p><p>font：設定儲存格字體</p><!--kg-card-begin: markdown--><table>
<thead>
<tr>
<th style="text-align:center">font</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">bold</td>
<td style="text-align:center">true/false</td>
</tr>
<tr>
<td style="text-align:center">italic</td>
<td style="text-align:center">true/false</td>
</tr>
<tr>
<td style="text-align:center">family</td>
<td style="text-align:center">字型名稱</td>
</tr>
<tr>
<td style="text-align:center">size</td>
<td style="text-align:center">字體大小</td>
</tr>
<tr>
<td style="text-align:center">color</td>
<td style="text-align:center">[&quot;#FFFFFF&quot;]</td>
</tr>
</tbody>
</table>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>fontStyle, err := f.NewStyle(`{&quot;font&quot;:{&quot;bold&quot;:true,&quot;italic&quot;:false,&quot;size&quot;:12,&quot;color&quot;:&quot;#FFFFFF&quot;}}`)
if err != nil {
    fmt.Println(err)
}</code></pre>
<!--kg-card-end: markdown--><p><strong>使用樣式</strong></p><!--kg-card-begin: markdown--><pre><code>//使用樣式設定column
err := xlsx.SetColStyle(sheetName, &quot;A1&quot;, patternStyle)

//使用樣式設定cell
err := xlsx.SetCellStyle(sheetName, &quot;A1&quot;, &quot;A1&quot;, gradientStyle)</code></pre>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[記憶體的時脈與頻寬]]></title><description><![CDATA[記憶體的時脈與頻寬]]></description><link>http://localhost:2368/clock-and-bandwidth/</link><guid isPermaLink="false">5e1de4127108022a40ad7b02</guid><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Tue, 14 Jan 2020 16:21:42 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/01/binary-code-binary-binary-system-byte-bits-administrator-1458897-pxhere.com.jpg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2020/01/binary-code-binary-binary-system-byte-bits-administrator-1458897-pxhere.com.jpg" alt="記憶體的時脈與頻寬"><p></p><h2 id="-">傳輸寬度</h2><h3 id="--1">每次可傳輸的量</h3><p>資料進出記憶體時會有寬度的限制，若頻寬是8bit，則代表一次可進去8個bit，若是64bit，則代表一次可同時傳輸64bit</p><hr><h2 id="--2">時脈</h2><h3 id="--3">一秒可傳輸多少次</h3><p>以Hz作為單位，代表一秒可以傳多少次，例如800MHz則為每秒800百萬次</p><hr><h2 id="--4">頻寬</h2><h3 id="--5">一秒可傳輸的量</h3><p>一秒可傳輸多少次 * 每次可傳輸的量 = 一秒可傳輸的量，以寬度為64bit及時脈為800HHz的例子來說，記憶體頻寬即為每秒64GB</p><p>64bit * 800MHz = 8Bytes * 800MHz = 6400 MBHz = 6.4GBHz = 每秒64GB</p>]]></content:encoded></item><item><title><![CDATA[使用Python爬蟲抓取網站資料]]></title><description><![CDATA[使用python抓取網站或網頁資料是再方便不過的了，常見的抓取方法包含抓取網站回應的JSON檔，或是直接抓取網頁內容並進行分析，以下紀錄兩種方法該如何實作。]]></description><link>http://localhost:2368/python-web-crawler/</link><guid isPermaLink="false">5e0e8ba22418ef16205128e7</guid><category><![CDATA[python]]></category><category><![CDATA[crawler]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Fri, 03 Jan 2020 16:48:36 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/01/python-logo.jpg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2020/01/python-logo.jpg" alt="使用Python爬蟲抓取網站資料"><p></p><p>使用python抓取網站或網頁資料是再方便不過的了，常見的抓取方法包含抓取網站回應的JSON檔，或是直接抓取網頁內容並進行分析，以下紀錄兩種方法該如何實作。</p><hr><h2 id="-">建立請求<br></h2><p>載入requests模組以建立HTTP請求</p><!--kg-card-begin: markdown--><pre><code>import requests</code></pre>
<!--kg-card-end: markdown--><p>建立GET請求</p><!--kg-card-begin: markdown--><pre><code>url = '' //填入目標網址以取得網頁內容
resp = requests.get(url) //建立get請求</code></pre>
<!--kg-card-end: markdown--><hr><h2 id="--1">解析請求<br></h2><h3 id="-json">目標為JSON</h3><p>使用<strong>json()</strong>方法解析內容，返回值(data)為字典</p><!--kg-card-begin: markdown--><pre><code>data = resp.json()</code></pre>
<!--kg-card-end: markdown--><h3 id="-html-">目標為HTML網頁內容</h3><p>需使用BeautifulSoup模組裡的方法，使用以下指令載入該模組</p><!--kg-card-begin: markdown--><pre><code>from bs4 import BeautifulSoup</code></pre>
<!--kg-card-end: markdown--><p>使用<strong>BeautifulSoup(htmlMarkup,'html5lib')</strong>方法解析網頁內容，返回值(soup)為&lt;class 'bs4.BeautifulSoup'&gt;</p><!--kg-card-begin: markdown--><pre><code>soup = BeautifulSoup(resp.text,'html5lib')</code></pre>
<!--kg-card-end: markdown--><hr><h2 id="--2">取得內容<br></h2><h3 id="-json-1">目標為JSON</h3><p>以台灣證券交易所-201901月個股日成交資訊為例，網址為'<a href="https://www.twse.com.tw/exchangeReport/STOCK_DAY?response=json&amp;date=20190101&amp;stockNo=2881">https://www.twse.com.tw/exchangeReport/STOCK_DAY?response=json&amp;date=20190101&amp;stockNo=2881</a>'，該請求返回的內容如下圖</p><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2020/01/bandicam-2020-01-03-22-28-14-255.jpg" class="kg-image" alt="使用Python爬蟲抓取網站資料"></figure><p>需使用Pandas模組裡的方法，使用以下指令載入該模組</p><!--kg-card-begin: markdown--><pre><code>import pandas as pd
</code></pre>
<!--kg-card-end: markdown--><p>我們需要取得data裡的0~20所有資訊做為內容，將其放入pandas的dataframe裡，並使用fields作為其欄位的標籤</p><!--kg-card-begin: markdown--><pre><code>//data[]為先前取得的資料，型態為字典
df = pd.DataFrame(data['data'],columns = data['fields'])</code></pre>
<!--kg-card-end: markdown--><p>若要使用foreach迴圈讀取或印出dataframe的內容時，需使用<strong>df.values</strong>作為範圍，若只使用df作為範圍會得到錯誤的結果</p><!--kg-card-begin: markdown--><pre><code>for row in df:
    print(row)
</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>&gt;日期
成交股數
成交金額
開盤價
最高價
最低價
收盤價
漲跌價差
成交筆數</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>for row in df.values:
    print(row)</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>&gt;['108/10/01' '8,895,183' '399,156,974' '44.85' '45.00' '44.75' '45.00' '+0.45' '3,310']
['108/10/02' '4,399,985' '196,735,002' '44.55' '44.85' '44.55' '44.75' '-0.25' '1,745']
...
['108/10/31' '17,527,040' '787,119,996' '45.40' '45.40' '44.55' '44.55' '-0.90' '5,017']</code></pre>
<!--kg-card-end: markdown--><h3 id="-html--1">目標為HTML網頁內容</h3><p>類別為'bs4.BeautifulSoup'的物件可使用以下方法<br><br>find()	//查詢第一筆符合的資料<br>find(htmlTag)	//查詢標籤類型為htmlTag的第一筆元素<br>find(id='elementID')	//查詢id為elementID的元素<br>find(htmlTag,class_='className')	//查詢標籤為htmlTag且class為className的第一筆元素<br>find(htmlTag,className)	//查詢標籤為htmlTag且class為className的第一筆元素<br><br>find_all()	//查詢所有符合的元素<br>find_all(htmlTag)	//查詢所有符合標籤類型為htmlTag的元素<br>find_all(id='elementID')	//查詢id為elementID的元素<br>find_all(htmlTag,class_='className')	//查詢標籤為htmlTag且class為className的所有元素<br>find_all(htmlTag,className)	//查詢標籤為htmlTag且class為className的所有元素</p><p>若使用find_all()查詢，可使用foreach迴圈歷遍所有查找到的元素</p><!--kg-card-begin: markdown--><pre><code>for content in soup.find_all('li'):
    print(content.string)</code></pre>
<!--kg-card-end: markdown--><p>使用<strong>.string</strong>方法取得元素的內容</p><!--kg-card-begin: markdown--><pre><code>soup = BeautifulSoup('&lt;h1 id=&quot;thisish1&quot;&gt;content&lt;/h1&gt;', 'html5lib')
print(soup.h1)</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>&gt;&lt;h1 id=&quot;thisish1&quot;&gt;content&lt;/h1&gt;</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>soup = BeautifulSoup('&lt;h1 id=&quot;thisish1&quot;&gt;content&lt;/h1&gt;', 'html5lib')
print(soup.h1.string)</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>&gt;content</code></pre>
<!--kg-card-end: markdown--><p>使用get('href')方法取得元素的href屬性</p><!--kg-card-begin: markdown--><pre><code>soup = BeautifulSoup('&lt;h1 href=&quot;katsuobushi.com&quot;&gt;content&lt;/h1&gt;', 'html5lib')
print(soup.h1.get('href'))</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>&gt;katsuobushi.com</code></pre>
<!--kg-card-end: markdown--><hr><h2 id="--3">輸出為檔案<br></h2><h3 id="-csv-">輸出為csv檔案</h3><p>需載入os及csv模組以使用open及writer方法</p><!--kg-card-begin: markdown--><pre><code>import os
import csv</code></pre>
<!--kg-card-end: markdown--><p>使用w模式開啟檔案，w模式為打開一個文件只用於寫入，若文件已存在則打开文件，並從頭開始編輯，原有内容會被刪除。若文件不存在，則創建新文件。</p><!--kg-card-begin: markdown--><pre><code>file = open(filepath,'w',newline='',encoding='utf-8-sig')</code></pre>
<!--kg-card-end: markdown--><p>使用csv.writer()創建一個writer</p><!--kg-card-begin: markdown--><pre><code>csvWriter = csv.writer(file)</code></pre>
<!--kg-card-end: markdown--><p>writerow()方法可將一列資料寫入到檔案中</p><!--kg-card-begin: markdown--><pre><code>csvWriter.writerow(row)</code></pre>
<!--kg-card-end: markdown--><p>寫入完畢後須關閉檔案，釋放資源</p><!--kg-card-begin: markdown--><pre><code>file.close()</code></pre>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[從外部中斷Goroutine]]></title><description><![CDATA[想要從外部終止一個正在執行中或無限迴圈的goroutine，必須使用channel將中斷訊息傳入使之中斷]]></description><link>http://localhost:2368/golang-kill-goroutine/</link><guid isPermaLink="false">5e019b6b9d3d371b842d0b37</guid><category><![CDATA[golang]]></category><category><![CDATA[goroutine]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Tue, 24 Dec 2019 06:29:39 GMT</pubDate><media:content url="http://localhost:2368/content/images/2019/12/golang-long-1.jpeg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2019/12/golang-long-1.jpeg" alt="從外部中斷Goroutine"><p></p><p>想要從外部終止一個正在執行中或無限迴圈的goroutine，必須使用channel將中斷訊息傳入使之中斷</p><hr><h3 id="-channel">建立Channel</h3><p>使用<strong>chan</strong>關鍵字宣告為channel，並指定通道類型</p><!--kg-card-begin: markdown--><pre><code>ch := make(chan struct{})</code></pre>
<!--kg-card-end: markdown--><p>若要傳入channel多個值，則必須指定buffer的大小，否則會造成deadlock</p><!--kg-card-begin: markdown--><pre><code>ch := make(chan struct{},10)//buffer大小為10</code></pre>
<!--kg-card-end: markdown--><p>設定目標函式的參數</p><!--kg-card-begin: markdown--><pre><code>func main(){
    ch := make(chan struct{})
    go spinner(80*time.Millisecond, ch)
}

func spinner(delay time.Duration, ch chan struct{}) {
    
}</code></pre>
<!--kg-card-end: markdown--><h3 id="-select-case-">使用select case控制流程</h3><p>select case只能用在有關channel的操作上，若多個case都符合，則會隨機挑選一個執行，若都不符合則執行default</p><!--kg-card-begin: markdown--><pre><code>func main(){
    ch := make(chan struct{})
    go spinner(80*time.Millisecond, ch)
}

func spinner(delay time.Duration, ch chan struct{}) {
    for {
        select {
        case &lt;-ch:
            return
        default:
            for _, r := range `-\|/` {
                fmt.Printf(&quot;\r%c&quot;, r)
                time.Sleep(delay)
            }
        }
    }
}</code></pre>
<!--kg-card-end: markdown--><h3 id="-goroutine">結束goroutine</h3><p>在要中斷的地方插入close(ch)以關閉channel</p><!--kg-card-begin: markdown--><pre><code>func main(){
    ch := make(chan struct{})
    go spinner(80*time.Millisecond, ch)
    close(ch)
}

func spinner(delay time.Duration, ch chan struct{}) {
    for {
        select {
        case &lt;-ch:
            return
        default:
            for _, r := range `-\|/` {
                fmt.Printf(&quot;\r%c&quot;, r)
                time.Sleep(delay)
            }
        }
    }
}</code></pre>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[Golang函式]]></title><description><![CDATA[Golang基礎 - 函式]]></description><link>http://localhost:2368/golang-function/</link><guid isPermaLink="false">5dfde8756c21ff2c7860dae4</guid><category><![CDATA[golang]]></category><category><![CDATA[golangBasic]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Sat, 21 Dec 2019 12:49:49 GMT</pubDate><media:content url="http://localhost:2368/content/images/2019/12/golang-long.jpeg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2019/12/golang-long.jpeg" alt="Golang函式"><p></p><h3 id="-">基本用法</h3><p>最基本的用法為使用func作為宣告函式的關鍵字，後面接上函式名稱(test)及回傳值(string)，這裡要注意的是必須指定回傳型態，否則會跳出錯誤訊息"too many arguments to return"</p><!--kg-card-begin: markdown--><pre><code>func test() string{
    return &quot;Hello&quot; 
}

func main(){
    fmt.Println(test())
}</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>&gt;Hello</code></pre>
<!--kg-card-end: markdown--><h3 id="--1">多個回傳值</h3><p>golang可以一次回傳多個值，在呼叫的地方必須使用多個變數接收傳回來的值</p><!--kg-card-begin: markdown--><pre><code>func test() (string,string){
    return &quot;Hello&quot;,&quot;katsuobushi&quot;
}

func main(){
    hlo,name := test()
    fmt.Println(hlo , name)
}</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>&gt;Hello katsuobushi</code></pre>
<!--kg-card-end: markdown--><h3 id="--2">傳入參數</h3><p>在函式名稱後的括號內加入一個或多個"<strong>變數名稱 變數型態"</strong>，以傳入參數</p><!--kg-card-begin: markdown--><pre><code>func foo(name string,age int){
    fmt.Println(name,age)
}

func main(){
    foo(&quot;katsuobushi&quot;,100)
}</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>&gt;katsuobushi 100
</code></pre>
<!--kg-card-end: markdown--><h3 id="--3">為回傳值命名</h3><p>可為回傳變數命名(宣告變數)，在回傳時可直接呼叫<strong>return</strong>就可以了</p><!--kg-card-begin: markdown--><pre><code>func foo(str string) (returnStr string) {
    returnStr = str
    return
}

func main() {
    fmt.Println(foo(&quot;Hello&quot;))
}</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>&gt;Hello</code></pre>
<!--kg-card-end: markdown--><h3 id="--4">類別的方法</h3><p>這個應該歸在類別裡介紹，但自己曾經搞混過所以在這裡註記下，這是類別裡宣告方法的方式，在函式的前面加上<strong>"(變數名稱 *類別)"</strong>，即表示宣告該類別的一個方法</p><p>在方法中使用<strong>變數名稱.方法</strong>或<strong>變數名稱.屬性</strong>表示存取呼叫該方法的物件(本例為co物件)的方法或屬性</p><p>假設使用co物件呼叫setCourse方法，則在setCourse方法裡的c即代表co物件，而c.courseID就代表co物件裡的courseID屬性</p><!--kg-card-begin: markdown--><pre><code>type course struct {
    courseID      string
    courseTeacher string
}

func (c *course) setCourse(id string, teacher string) {
    c.courseID = id
    c.courseTeacher = teacher
}

func (c *course) print() {
    fmt.Println(c.courseID, c.courseTeacher)
}

func main() {
    var co course
    co.setCourse(&quot;3452&quot;, &quot;GolangProgramming&quot;)
    co.print()
}
</code></pre>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[計算Wildcard Mask]]></title><description><![CDATA[在設置ACL(Access Control List)時，會用到Wildcard Mask標示在範圍內的IP位址，這篇筆記記錄如何使用wildcard mask計算IP範圍的起點及終點]]></description><link>http://localhost:2368/wildcard-mask/</link><guid isPermaLink="false">5df3b117bd62740960b57409</guid><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Fri, 13 Dec 2019 16:49:37 GMT</pubDate><media:content url="http://localhost:2368/content/images/2019/12/binary-code-binary-binary-system-byte-bits-administrator-1458897-pxhere.com.jpg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2019/12/binary-code-binary-binary-system-byte-bits-administrator-1458897-pxhere.com.jpg" alt="計算Wildcard Mask"><p></p><p>在設置ACL(Access Control List)時，會用到Wildcard Mask標示在範圍內的IP位址，這篇筆記記錄如何使用wildcard mask計算IP範圍的起點及終點</p><hr><h2 id="-">簡介<br></h2><p>wildcard mask使用0和1表示<br>0代表匹配，1代表忽略<br>以下使用8bit作為示範</p><!--kg-card-begin: markdown--><table>
<thead>
<tr>
<th>128</th>
<th>64</th>
<th>32</th>
<th>16</th>
<th>8</th>
<th>4</th>
<th>2</th>
<th>1</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>匹配所有位元</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>忽略後六個位元</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>忽略後四個位元</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>忽略前六個位元</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>忽略所有位元</td>
</tr>
</tbody>
</table>
<!--kg-card-end: markdown--><hr><h2 id="--1">計算<br></h2><p>以指令 <strong>access list 50 permit 192.168.122.128 0.0.0.63</strong> 為例</p><!--kg-card-begin: markdown--><table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">DEC</th>
<th style="text-align:center">BIN</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IP Address</td>
<td style="text-align:center">192.168.122.128</td>
<td style="text-align:center">11000000.10101000.01111010.10000000</td>
</tr>
<tr>
<td style="text-align:center">Wildcard Mask</td>
<td style="text-align:center">0.0.0.63</td>
<td style="text-align:center">00000000.00000000.00000000.00111111</td>
</tr>
<tr>
<td style="text-align:center">IP位址範圍起點</td>
<td style="text-align:center">192.168.122.128</td>
<td style="text-align:center">11000000.10101000.01111010.10000000</td>
</tr>
<tr>
<td style="text-align:center">IP位址範圍終點</td>
<td style="text-align:center">192.168.122.191</td>
<td style="text-align:center">11000000.10101000.01111010.10111111</td>
</tr>
</tbody>
</table>
<!--kg-card-end: markdown--><p>1.計算IP位址的二進位值<br>    192.168.122.128 -&gt; 11000000.10101000.01111010.10000000<br>2.計算Mask的二進位值<br>    0.0.0.63 -&gt; 00000000.00000000.00000000.00111111<br>3.觀察Mask的值為最後6個bit，故範圍為10000000~10111111</p><p></p><p>以指令 <strong>access list 50 permit 192.51.100.58 0.0.0.63</strong> 為例</p><!--kg-card-begin: markdown--><table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">DEC</th>
<th style="text-align:center">BIN</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IP Address</td>
<td style="text-align:center">192.51.100.58</td>
<td style="text-align:center">11000000.00110011.01100100.00111010</td>
</tr>
<tr>
<td style="text-align:center">Wildcard Mask</td>
<td style="text-align:center">0.0.0.63</td>
<td style="text-align:center">00000000.00000000.00000000.00111111</td>
</tr>
<tr>
<td style="text-align:center">IP位址範圍起點</td>
<td style="text-align:center">192.51.100.0</td>
<td style="text-align:center">11000000.00110011.01100100.00000000</td>
</tr>
<tr>
<td style="text-align:center">IP位址範圍終點</td>
<td style="text-align:center">192.51.100.63</td>
<td style="text-align:center">11000000.00110011.01100100.00111111</td>
</tr>
</tbody>
</table>
<!--kg-card-end: markdown--><p>1.計算IP位址的二進位值<br>    192.51.100.58 -&gt; 11000000.00110011.01100100.00111010<br>2.計算Mask的二進位值<br>    0.0.0.63 -&gt; 00000000.00000000.00000000.00111111<br>3.觀察Mask的值為最後6個bit，故範圍為00000000~00111111</p><p><br>        </p>]]></content:encoded></item><item><title><![CDATA[使用Ghost和GitHub Pages建立網頁]]></title><description><![CDATA[一直以來都有個困擾，就是查個程式寫法或是軟體操作方法每次都很快就忘記，所以想寫個Blog紀錄自己的手順，先前曾想過直接寫個網頁PUSH到GitHub上，但實在有點累( ˘･з･)，偶然又看到有個很喜歡的排版是用Ghost建立的，因此使用Ghost+GitHub的形式建立部落格]]></description><link>http://localhost:2368/ghost-github-webpage/</link><guid isPermaLink="false">5de291f8c31a24007887a233</guid><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Sat, 30 Nov 2019 17:57:56 GMT</pubDate><media:content url="http://localhost:2368/content/images/2019/11/Ghost-Logo.svg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2019/11/Ghost-Logo.svg" alt="使用Ghost和GitHub Pages建立網頁"><p></p><p>一直以來都有個困擾，就是查個程式寫法或是軟體操作方法每次都很快就忘記，所以想寫個Blog紀錄自己的手順，先前曾想過直接寫個網頁PUSH到GitHub上，但實在有點累( ˘･з･)，偶然又看到有個很喜歡的排版是用Ghost建立的，因此使用Ghost+GitHub的形式建立部落格</p><hr><h2 id="-ghost">安裝Ghost</h2><p>1.安裝Ghost-CLI‌‌   使用npm或yarn指令安裝Ghost-CLI</p><!--kg-card-begin: markdown--><pre><code>npm install ghost-cli@latest -g</code></pre>
<!--kg-card-end: markdown--><p>2.安裝Ghost‌‌   開啟終端機，移動到要建立Ghost的目錄並使用指令安裝Ghost</p><!--kg-card-begin: markdown--><pre><code>ghost install local</code></pre>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/11/bandicam-2019-12-01-00-43-12-343-2.jpg" class="kg-image" alt="使用Ghost和GitHub Pages建立網頁"></figure><p>3.安裝完成後開啟git bash切換到同一目錄並初始化目錄</p><!--kg-card-begin: markdown--><pre><code>git init git add -A git commit -m &quot;Initial repository&quot;</code></pre>
<!--kg-card-end: markdown--><p>4.安裝npm並更新repository</p><!--kg-card-begin: markdown--><pre><code>npm install 
git add -A 
git commit -m 'Installed Node dependencies'</code></pre>
<!--kg-card-end: markdown--><p>5.安裝knex-migrator並更新repository</p><!--kg-card-begin: markdown--><pre><code>npm install -g knex-migrator</code></pre>
<!--kg-card-end: markdown--><p>6.初始化資料庫</p><!--kg-card-begin: markdown--><pre><code>knex-migrator</code></pre>
<!--kg-card-end: markdown--><hr><h2 id="-ghost-1">設定Ghost</h2><p>1.移動到已安裝Ghost的目錄並輸入指令開啟Ghost</p><!--kg-card-begin: markdown--><pre><code>ghost start</code></pre>
<!--kg-card-end: markdown--><p>2.一般使用<a href="http://localhost:2368/ghost">http://localhost:2368/ghost</a>開啟Ghost的管理介面，但因為先前已經在另一個地方裝過一個Ghost，所以畫面顯示以<a href="http://localhost:2369/ghost/">http://localhost:2369/ghost</a>/開啟管理介面</p><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/11/bandicam-2019-12-01-00-50-41-339-1.jpg" class="kg-image" alt="使用Ghost和GitHub Pages建立網頁"></figure><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/11/bandicam-2019-12-01-00-54-54-621-1.jpg" class="kg-image" alt="使用Ghost和GitHub Pages建立網頁"></figure><p>3.填寫網站名稱及作者基本資料</p><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/11/bandicam-2019-12-01-00-54-57-345-1.jpg" class="kg-image" alt="使用Ghost和GitHub Pages建立網頁"></figure><p>4.可輸入email邀請其他作者一起協作，只有自己使用的話則按下方直接進入管理介面</p><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/11/bandicam-2019-12-01-00-55-57-353-1.jpg" class="kg-image" alt="使用Ghost和GitHub Pages建立網頁"></figure><p>5.更新repository</p><!--kg-card-begin: markdown--><pre><code>git add -A 
git commit -m 'Finished local Ghost setup'</code></pre>
<!--kg-card-end: markdown--><hr><h2 id="-">將網頁輸出為檔案</h2><p>1.使用wget輸出網頁到docs資料夾內<br>   --mirror : 鏡像下載所有檔案相當於-N -r -l inf --no-remove-listing選項<br>        -N : 若遠端檔案較新則下載檔案<br>        -r : 遞迴下載<br>        -l : 最大搜尋深度(0或inf表示無限)<br>        --no-remove-listing : 不刪除<strong>.listing</strong>檔案<br>   --convert-links : 轉換檔案內路徑為符合本地目錄的路徑   <br>   --page-requisites : 下載所有顯示網頁所需的檔案，例如圖片等<br>   -nH : 不建立名稱為網站名稱的目錄，直接在當前目錄建立檔案<br>   --no-parent : 不進入上層目錄<br>   -P : 指定下載目錄</p><!--kg-card-begin: markdown--><pre><code>wget --mirror --convert-links --page-requisites -nH --no-parent -P docs http://localhost:2368/</code></pre>
<!--kg-card-end: markdown--><p>2.由於從Ghost抓下來的css、js的檔名和html內的相關路徑都會被加上類似下圖.css後方的字串，若直接傳到GitHub Pages上的話會讀不到，我們可使用Notepad++將目錄中所有檔案中有包括此字串的替換為空字串</p><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/11/bandicam-2019-12-01-01-13-41-348-1.jpg" class="kg-image" alt="使用Ghost和GitHub Pages建立網頁"></figure><p>3.開啟Notepad++，點選<strong>在檔案中尋找</strong></p><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/11/bandicam-2019-12-01-01-19-16-765-1.jpg" class="kg-image" alt="使用Ghost和GitHub Pages建立網頁"></figure><p>4.輸入要刪除的字串並按下<strong>在多個檔案中取代</strong></p><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/11/bandicam-2019-12-01-01-23-25-708-1.jpg" class="kg-image" alt="使用Ghost和GitHub Pages建立網頁"></figure><p>5.更改docs/assets內built、css和js資料夾內所有包含該字串的檔名</p><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/11/bandicam-2019-12-01-01-27-47-025-1.jpg" class="kg-image" alt="使用Ghost和GitHub Pages建立網頁"></figure><p>6.更新repository</p><!--kg-card-begin: markdown--><pre><code>git add -A 
git commit -m &quot;Export website to docs file;&quot;</code></pre>
<!--kg-card-end: markdown--><hr><h2 id="push-github">PUSH檔案到GitHub</h2><p>1.設定遠端倉庫</p><!--kg-card-begin: markdown--><pre><code>git remote add origin &lt;webURL|SSH Key&gt;</code></pre>
<!--kg-card-end: markdown--><p>2.將master分支推送到origin倉庫</p><!--kg-card-begin: markdown--><pre><code>git push -u origin master</code></pre>
<!--kg-card-end: markdown--><hr><h2 id="-github-pages">設定GitHub Pages</h2><p>1.進入剛剛上傳的GitHub的Repository，點選settings標籤</p><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/11/bandicam-2019-12-01-01-39-39-594-1.jpg" class="kg-image" alt="使用Ghost和GitHub Pages建立網頁"></figure><p>2.尋找GitHub Pages區塊，選擇master branch /docs folder作為網頁來源</p><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/11/bandicam-2019-12-01-01-42-52-205-1.jpg" class="kg-image" alt="使用Ghost和GitHub Pages建立網頁"></figure><hr><h2 id="--1">已可瀏覽網頁</h2><p>在網址列輸入http://帳號.github.io/RepositoryName即可瀏覽網頁</p>]]></content:encoded></item></channel></rss>
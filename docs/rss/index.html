<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[柴魚筆記本]]></title><description><![CDATA[程式 • 軟體 • 攝影]]></description><link>http://localhost:2368/</link><image><url>http://localhost:2368/favicon.png</url><title>柴魚筆記本</title><link>http://localhost:2368/</link></image><generator>Ghost 3.1</generator><lastBuildDate>Tue, 24 Nov 2020 18:55:16 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[[MQTT]Mosquitto Server 安裝與啟動]]></title><description><![CDATA[在使用MQTT進行資料傳遞時，會需要一個代理人，也就是MQTT Broker，作為訂閱/發布的橋樑，Mosquitto Server是一個開源的MQTT的Server，本篇筆記紀錄在Windows下如何安裝並開啟MQTT Server]]></description><link>http://localhost:2368/mqtt-mosquitto-server-init/</link><guid isPermaLink="false">5fbd476923e6d4238ca4b81e</guid><category><![CDATA[mqtt]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Tue, 24 Nov 2020 18:53:17 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/11/MQTT.png" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2020/11/MQTT.png" alt="[MQTT]Mosquitto Server 安裝與啟動"><p>在使用MQTT進行資料傳遞時，會需要一個代理人，也就是MQTT Broker，作為訂閱/發布的橋樑，Mosquitto Server是一個開源的MQTT的Server，本篇筆記紀錄在Windows下如何安裝並開啟MQTT Server</p><!--kg-card-begin: markdown--><h2 id>環境</h2>
<ul>
<li>Windows10 x64 2004</li>
<li>mosquitto-1.6.12a</li>
</ul>
<h2 id>下載</h2>
<p>進入<a href="https://mosquitto.org/download/">Mosquitto-Download</a>下載頁面進行下載<br>
<img src="http://localhost:2368/content/images/2020/11/1-2.png" alt="[MQTT]Mosquitto Server 安裝與啟動"></p>
<h2 id>安裝</h2>
<p>點擊已下載完成的安裝檔進行安裝<br>
<img src="http://localhost:2368/content/images/2020/11/2-2.png" alt="[MQTT]Mosquitto Server 安裝與啟動"><br>
<img src="http://localhost:2368/content/images/2020/11/3-2.png" alt="[MQTT]Mosquitto Server 安裝與啟動"><br>
可選擇安裝路徑<br>
<img src="http://localhost:2368/content/images/2020/11/4-2.png" alt="[MQTT]Mosquitto Server 安裝與啟動"><br>
安裝完成<br>
<img src="http://localhost:2368/content/images/2020/11/5-1.png" alt="[MQTT]Mosquitto Server 安裝與啟動"></p>
<h2 id>啟動</h2>
<p>使用<strong>工作管理員</strong>或<strong>執行</strong>開啟<strong>服務</strong>功能</p>
<h3 id>使用工作管理員開啟服務</h3>
<p>在開始列點選右鍵，點擊&quot;工作管理員&quot;以開啟<br>
<img src="http://localhost:2368/content/images/2020/11/6-1.png" alt="[MQTT]Mosquitto Server 安裝與啟動"></p>
<h3 id>使用執行開啟服務</h3>
<p>按下快捷鍵<code>windows+R</code>並輸入services.msc開啟服務功能<br>
<img src="http://localhost:2368/content/images/2020/11/7-1.png" alt="[MQTT]Mosquitto Server 安裝與啟動"></p>
<p>尋找mosquitto並點選右鍵啟動服務<br>
<img src="http://localhost:2368/content/images/2020/11/8-1.png" alt="[MQTT]Mosquitto Server 安裝與啟動"><br>
<img src="http://localhost:2368/content/images/2020/11/9.png" alt="[MQTT]Mosquitto Server 安裝與啟動"></p>
<h2 id>查看伺服器狀態</h2>
<p>在終端機輸入<code>netstat -an</code>查看作用中的連線，以檢查伺服器是否正常運行<br>
<img src="http://localhost:2368/content/images/2020/11/10.png" alt="[MQTT]Mosquitto Server 安裝與啟動"></p>
<h2 id>在防火牆中開啟連接埠</h2>
<p>進入控制台 &gt; 系統及安全性 &gt; Windows Defender防火牆 &gt; 進階設定，或直接按下快捷鍵<code>windows+R</code>並輸入WF.msc，開啟<strong>具有進階安全性的 Windows Defender 防火牆</strong></p>
<p>在<strong>輸入規則</strong>中點選新增規則<br>
<img src="http://localhost:2368/content/images/2020/11/11.png" alt="[MQTT]Mosquitto Server 安裝與啟動"><br>
建立指定連接埠的規則<br>
<img src="http://localhost:2368/content/images/2020/11/12.png" alt="[MQTT]Mosquitto Server 安裝與啟動"><br>
輸入1883連接埠進行設定<br>
<img src="http://localhost:2368/content/images/2020/11/13.png" alt="[MQTT]Mosquitto Server 安裝與啟動"><br>
<img src="http://localhost:2368/content/images/2020/11/14.png" alt="[MQTT]Mosquitto Server 安裝與啟動"><br>
<img src="http://localhost:2368/content/images/2020/11/15.png" alt="[MQTT]Mosquitto Server 安裝與啟動"><br>
指定規則名稱<br>
<img src="http://localhost:2368/content/images/2020/11/16.png" alt="[MQTT]Mosquitto Server 安裝與啟動"></p>
<h2 id>安裝完成</h2>
<p>完成以上設定後就可以透過1883連接埠對MQTT Server進行連線啦</p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[[Vue]將Vue-Router加入到專案中]]></title><description><![CDATA[在使用vue時，有時會需要在畫面中切換component，這時vue-router就派上用場啦，vue-router常常被用在single-page application中，這次的期中專題因為要將舊網頁變成single-page app，所以必須先了解如何將vue-router加入到專案中，方便後續使用]]></description><link>http://localhost:2368/vue-vuerouter-init/</link><guid isPermaLink="false">5faab3648214a931cca9350d</guid><category><![CDATA[Vue]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Tue, 10 Nov 2020 15:39:37 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/11/vue-1.jpg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2020/11/vue-1.jpg" alt="[Vue]將Vue-Router加入到專案中"><p>在使用vue時，有時會需要在畫面中切換component，這時vue-router就派上用場啦，vue-router常常被用在single-page application中，這次的期中專題因為要將舊網頁變成single-page app，所以必須先了解如何將vue-router加入到專案中，方便後續使用</p><!--kg-card-begin: markdown--><h2 id>環境</h2>
<ul>
<li>Windows10 x64 2004</li>
<li>Node.js - v12.19.0</li>
<li>Vue - @vue/cli 4.5.8</li>
<li>vue-router@3.4.9</li>
</ul>
<h2 id="vuerouter">安裝Vue-Router</h2>
<p>要將Vue-Router加入到專案可使用CDN嵌入，或是使用npm安裝</p>
<h3 id="cdn">CDN</h3>
<p>在<code>&lt;head&gt;&lt;/head&gt;</code>標籤中加入下面這行標籤即可將Vue-Router加入到專案</p>
<pre><code class="language-htmlmixed">&lt;head&gt;
    &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
</code></pre>
<h3 id="npm">npm</h3>
<p>開啟終端機，並輸入以下指令，即可安裝Vue-Router</p>
<pre><code class="language-shell">npm install vue-router
</code></pre>
<h2 id="vue">建立Vue專案</h2>
<p>在使用Vue-Router之前建議先建立Vue專案，建立專案的方法請參考<a href="https://vincent87720.github.io/Blog/vue-vuecli-init/index.html">[Vue]使用Vue CLI建立專案</a></p>
<h2 id="component">加入component</h2>
<p>在已建立好的專案中尋找src資料夾，並在src目錄下新增views目錄<br>
<img src="http://localhost:2368/content/images/2020/11/1-1.png" alt="[Vue]將Vue-Router加入到專案中"><br>
在views目錄中放入想要進行切換的component，這邊以Home.vue和About.vue進行示範<br>
<img src="http://localhost:2368/content/images/2020/11/2-1.png" alt="[Vue]將Vue-Router加入到專案中"><br>
<strong>Home.vue</strong></p>
<pre><code class="language-htmlmixed">&lt;template&gt;
  &lt;div class=&quot;home&quot;&gt;
    &lt;h1&gt;Home page&lt;/h1&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {

}
&lt;/script&gt;

</code></pre>
<p><strong>About.vue</strong></p>
<pre><code class="language-htmlmixed">&lt;template&gt;
  &lt;div class=&quot;about&quot;&gt;
    &lt;h1&gt;About page&lt;/h1&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {

}
&lt;/script&gt;

</code></pre>
<h2 id>建立路由目錄與檔案</h2>
<p>接著在src目錄下新增router資料夾，並新增index.js檔案<br>
<img src="http://localhost:2368/content/images/2020/11/3-1.png" alt="[Vue]將Vue-Router加入到專案中"><br>
在檔案中可自由新增或刪除component，並配置component對應的路由</p>
<p><strong>index.js</strong></p>
<pre><code class="language-javascript">import Vue from 'vue'
import VueRouter from 'vue-router'

//這裡可以自行import需要的component
import Home from '../views/Home.vue'
import About from '../views/About.vue'

Vue.use(VueRouter)

//建立路由routes
const routes = [
    {
        path: '/',
        component: Home
    },
    {
        path: '/About',
        component: About
    }
]

//建立Vue-Router的instance，並將routes的配置帶入
const router = new VueRouter({
    mode: 'hash',
    routes
})
//匯出成模組給Vue使用
export default router

</code></pre>
<h2 id>匯入路由</h2>
<p><img src="http://localhost:2368/content/images/2020/11/4-1.png" alt="[Vue]將Vue-Router加入到專案中"><br>
在<code>main.js</code>中加入以下指令載入router模組</p>
<pre><code class="language-javascript">import router from './router'
</code></pre>
<p>並在new Vue中加入router</p>
<pre><code class="language-javascript">new Vue({
  router,
  render: h =&gt; h(App)
}).$mount('#app')
</code></pre>
<p><strong>main.js</strong></p>
<pre><code class="language-javascript">import Vue from 'vue'
import App from './App.vue'
import router from './router'

Vue.config.productionTip = false

new Vue({
  router,
  render: h =&gt; h(App)
}).$mount('#app')

</code></pre>
<h2 id>加入路由連結</h2>
<p>在<code>App.vue</code>中加入Home和About的連結<br>
<img src="http://localhost:2368/content/images/2020/11/5.png" alt="[Vue]將Vue-Router加入到專案中"></p>
<pre><code class="language-javascript">&lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt;|
&lt;router-link to=&quot;/About&quot;&gt;About&lt;/router-link&gt;
&lt;router-view&gt;&lt;/router-view&gt;
</code></pre>
<p><strong>App.vue</strong></p>
<pre><code class="language-htmlmixed">&lt;template&gt;
  &lt;v-app&gt;
    &lt;v-main&gt;
      &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt;|
      &lt;router-link to=&quot;/About&quot;&gt;About&lt;/router-link&gt;
      &lt;router-view&gt;&lt;/router-view&gt;
    &lt;/v-main&gt;
  &lt;/v-app&gt;
&lt;/template&gt;

&lt;script&gt;

export default {
  name: 'App',

  components: {
  },

  data: () =&gt; ({
    //
  }),
};
&lt;/script&gt;
</code></pre>
<p>到這裡我們已經建立好路由了，接著我們使用開發者模式查看成果</p>
<h2 id>啟動開發者模式</h2>
<p>在終端機輸入命令啟動開發者模式</p>
<pre><code class="language-shell">npm run serve
</code></pre>
<p><img src="http://localhost:2368/content/images/2020/11/6.png" alt="[Vue]將Vue-Router加入到專案中"><br>
依照指示在瀏覽器輸入網址</p>
<h2 id>完成</h2>
<p>現在已可使用連結切換component!<br>
<img src="http://localhost:2368/content/images/2020/11/7.png" alt="[Vue]將Vue-Router加入到專案中"><br>
<img src="http://localhost:2368/content/images/2020/11/8.png" alt="[Vue]將Vue-Router加入到專案中"></p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[[Vue]Vuetify安裝與使用]]></title><description><![CDATA[Vuetify是一個Vue的UI框架，有許多精美和現成的組件可讓我們快速進行網頁排版及呈現，由於這篇文章撰寫時vuetify尚未支援Vue3，所以本篇文章以Vue2為例，示範如何將vuetify加入到Vue2專案中]]></description><link>http://localhost:2368/vue-vuetify-init/</link><guid isPermaLink="false">5fa82780420dbd31a087d3d1</guid><category><![CDATA[Vue]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Sun, 08 Nov 2020 17:18:40 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/11/vue.jpg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2020/11/vue.jpg" alt="[Vue]Vuetify安裝與使用"><p>Vuetify是一個Vue的UI框架，有許多精美和現成的組件可讓我們快速進行網頁排版及呈現，由於這篇文章撰寫時vuetify尚未支援Vue3，所以本篇文章以Vue2為例，示範如何將vuetify加入到Vue2專案中</p><!--kg-card-begin: markdown--><h2 id>環境</h2>
<ul>
<li>Windows10 x64 2004</li>
<li>Node.js - 6.12.1</li>
<li>Vue - @vue/cli 4.5.8</li>
<li>vue-cli-plugin-vuetify@2.0.7</li>
</ul>
<h2 id="vue">建立Vue專案</h2>
<p>在使用Vuetify之前必須先建立Vue專案，建立專案的方法請參考<a href="https://vincent87720.github.io/Blog/vue-vuecli-init/index.html">[Vue]使用Vue CLI建立專案</a></p>
<h2 id="vuetify">將Vuetify加入到專案</h2>
<p>切換到專案根目錄，並開啟終端機輸入指令，將Vuetify加入到專案</p>
<pre><code class="language-shell">vue add vuetify
</code></pre>
<p><img src="http://localhost:2368/content/images/2020/11/1.png" alt="[Vue]Vuetify安裝與使用"><br>
選擇<code>Default (recommended)</code><br>
<img src="http://localhost:2368/content/images/2020/11/2.png" alt="[Vue]Vuetify安裝與使用"><br>
安裝完成後在終端機輸入指令啟動開發者模式</p>
<pre><code class="language-shell">npm run serve
</code></pre>
<p><img src="http://localhost:2368/content/images/2020/11/3.png" alt="[Vue]Vuetify安裝與使用"><br>
成功啟動後會顯示網址，在瀏覽器網址列輸入網址即可瀏覽目前專案的狀態<br>
在瀏覽器輸入網址執行後，若出現以下畫面代表安裝成功<br>
<img src="http://localhost:2368/content/images/2020/11/4.png" alt="[Vue]Vuetify安裝與使用"></p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[[Vue]使用Vue CLI建立專案]]></title><description><![CDATA[在之前的課堂裡，我們都是直接開一個html檔案然後把vue寫在裡頭，這次助教介紹了Vue CLI，Vue CLI是一個官方出的工具，可以直接開一個測試用的伺服器，讓開發更方便，並且可以將程式碼打包，方便某些情況下的部屬]]></description><link>http://localhost:2368/vue-vuecli-init/</link><guid isPermaLink="false">5f986050c88dfb30b47715dc</guid><category><![CDATA[Vue]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Tue, 27 Oct 2020 18:13:25 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/10/vue.jpg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2020/10/vue.jpg" alt="[Vue]使用Vue CLI建立專案"><p>在之前的課堂裡，我們都是直接開一個html檔案然後把vue寫在裡頭，這次助教介紹了Vue CLI，Vue CLI是一個官方出的工具，可以直接開一個測試用的伺服器，讓開發更方便，並且可以將程式碼打包，方便某些情況下的部屬</p><!--kg-card-begin: markdown--><h2 id>環境</h2>
<ul>
<li>Windows10 x64 2004</li>
<li>Node.js - v12.19.0</li>
<li>Vue - @vue/cli 4.5.8</li>
</ul>
<h2 id="vuecli">下載並安裝VueCLI</h2>
<p>開啟終端機並輸入指令進行安裝</p>
<pre><code class="language-shell=cmd">npm install -g @vue/cli
</code></pre>
<p>輸入指令驗證VueCLI版本</p>
<pre><code class="language-shell=cmd">vue -V
</code></pre>
<h2 id="vue">建立Vue專案</h2>
<p><img src="http://localhost:2368/content/images/2020/10/1.png" alt="[Vue]使用Vue CLI建立專案"><br>
開啟終端機並輸入指令開啟建立專案程式，指令中的<code>&lt;name&gt;</code>使用自行定義的專案名稱替換掉</p>
<pre><code class="language-shell=cmd">vue create &lt;name&gt;
</code></pre>
<p><img src="http://localhost:2368/content/images/2020/10/2.png" alt="[Vue]使用Vue CLI建立專案"><br>
選擇要使用哪項模式建立專案，我們使用Manually select features進行自定義設定</p>
<p><img src="http://localhost:2368/content/images/2020/10/3.png" alt="[Vue]使用Vue CLI建立專案"><br>
預設會有三個選項已被勾選，為了防止一直報錯，我們按下方向鍵移動選項到Linter / Formatter並按下空白鍵，暫時將此選項取消勾選</p>
<p>接著移動到Choose Vue version並按下Enter鍵選擇Vue版本</p>
<p><img src="http://localhost:2368/content/images/2020/10/4.png" alt="[Vue]使用Vue CLI建立專案"><br>
這裡我們選擇使用Vue3的版本</p>
<p><img src="http://localhost:2368/content/images/2020/10/5.png" alt="[Vue]使用Vue CLI建立專案"><br>
接著選擇In dedicated config files選項</p>
<p><img src="http://localhost:2368/content/images/2020/10/6.png" alt="[Vue]使用Vue CLI建立專案"><br>
輸入y後按下Enter確認以上安裝資訊</p>
<p><img src="http://localhost:2368/content/images/2020/10/7.png" alt="[Vue]使用Vue CLI建立專案"><br>
若要將本次的選擇儲存成預設設定可填入名稱紀錄本次設定，下次在下vue create指令時就可以選擇此次的設定建立專案<br>
<img src="http://localhost:2368/content/images/2020/10/8.png" alt="[Vue]使用Vue CLI建立專案"></p>
<p><img src="http://localhost:2368/content/images/2020/10/9.png" alt="[Vue]使用Vue CLI建立專案"><br>
建立好專案後就可以在目錄內看到Vue的專案檔案了</p>
<h2 id="vue">設定Vue專案</h2>
<p>為了確保可以正確讀取assets的內容，我們需要修改@vue/cli-serve/lib/option.js內的參數或是以新增vue.config.js檔案的方式進行設定<br>
<a href="https://cli.vuejs.org/zh/config">Vue配置参考</a> <a href="http://wm.dyu.edu.tw/testweb/myWeb/">VueCli設定</a></p>
<ul>
<li>於Public資料夾下新增tools資料夾</li>
<li>在專案<strong>根目錄</strong>新增vue.config.js檔案，並輸入以下內容</li>
</ul>
<pre><code class="language-javascript">module.exports = {
    productionSourceMap:false,
    indexPath: 'index.html',
    assetsDir: 'tools',
    publicPath : ''
}
</code></pre>
<h2 id>啟動開發者模式伺服器</h2>
<p>開啟終端機並輸入指令</p>
<pre><code class="language-shell">npm run serve
</code></pre>
<p><img src="http://localhost:2368/content/images/2020/10/10.png" alt="[Vue]使用Vue CLI建立專案"><br>
出現Done就代表完成了，點選下方網址便可以使用瀏覽器觀看專案內網頁的狀態囉</p>
<h2 id>打包檔案</h2>
<p>當我們寫好網頁之後，我們可以使用build指令將檔案打包，便可以部屬到伺服器上了</p>
<pre><code class="language-shell=cmd">npm run build
</code></pre>
<p>執行之後在根目錄裡面出現dist資料夾就是已經打包好的檔案囉</p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[[C#]使用Npgsql連接到PostgreSQL server]]></title><description><![CDATA[<!--kg-card-begin: markdown--><h2 id>環境</h2>
<ul>
<li>Windows 10 x64</li>
<li>Visual Studio Community 2019 v16.2.2</li>
<li>Npgsql v4.1.4</li>
</ul>
<h2 id>安裝</h2>
<p>開啟visual studio後點選&quot;<strong>工具</strong>-&gt;<strong>NuGet套件管理員</strong>-&gt;<strong>管理方案的NuGet套件</strong>&quot;<br>
<img src="http://localhost:2368/content/images/2020/09/1.png" alt="1"><br>
點選Npgsql，勾選右方會執行到此套件的專案，再點選安裝<br>
<img src="http://localhost:2368/content/images/2020/09/2.png" alt="2"><br>
按確定進行安裝<br>
<img src="http://localhost:2368/content/images/2020/09/3.png" alt="3"></p>
<h2 id>建立連線</h2>
<p>設定好<code>host</code> <code>post</code> <code>username</code> <code>password</code> <code>database</code>等連線資訊後，使用<code>NpgsqlConnection</code>建立一個新連線，再使用Open()方法開啟連線</p>
<pre><code class="language-csharp">class Program
{
    
    static void Main(string[</code></pre>]]></description><link>http://localhost:2368/csharp-connect-to-postgresql/</link><guid isPermaLink="false">5f4ffba3a1fe94288c940dc2</guid><category><![CDATA[C#]]></category><category><![CDATA[NuGet]]></category><category><![CDATA[PostgreSQL]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Wed, 02 Sep 2020 20:21:06 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/09/dotNET.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><h2 id>環境</h2>
<ul>
<li>Windows 10 x64</li>
<li>Visual Studio Community 2019 v16.2.2</li>
<li>Npgsql v4.1.4</li>
</ul>
<h2 id>安裝</h2>
<img src="http://localhost:2368/content/images/2020/09/dotNET.png" alt="[C#]使用Npgsql連接到PostgreSQL server"><p>開啟visual studio後點選&quot;<strong>工具</strong>-&gt;<strong>NuGet套件管理員</strong>-&gt;<strong>管理方案的NuGet套件</strong>&quot;<br>
<img src="http://localhost:2368/content/images/2020/09/1.png" alt="[C#]使用Npgsql連接到PostgreSQL server"><br>
點選Npgsql，勾選右方會執行到此套件的專案，再點選安裝<br>
<img src="http://localhost:2368/content/images/2020/09/2.png" alt="[C#]使用Npgsql連接到PostgreSQL server"><br>
按確定進行安裝<br>
<img src="http://localhost:2368/content/images/2020/09/3.png" alt="[C#]使用Npgsql連接到PostgreSQL server"></p>
<h2 id>建立連線</h2>
<p>設定好<code>host</code> <code>post</code> <code>username</code> <code>password</code> <code>database</code>等連線資訊後，使用<code>NpgsqlConnection</code>建立一個新連線，再使用Open()方法開啟連線</p>
<pre><code class="language-csharp">class Program
{
    
    static void Main(string[] args)
    {
        string host = &quot;localhost&quot;;
        string port = &quot;5432&quot;;
        string username = &quot;postgres&quot;;
        string password = &quot;password&quot;;
        string database = &quot;postgis&quot;;
        string connStr = $&quot;Host={host};Port={port};Username={username};Password={password};Database={database};&quot;;
        using (NpgsqlConnection pgconn = new NpgsqlConnection(connStr))
        {
            pgconn.Open();
        }

    }
}
</code></pre>
<h2 id>執行查詢</h2>
<h3 id="npgsqldatareader">方法一：使用NpgsqlDataReader讀取資料</h3>
<p>執行查詢必須用到先前建立好的連線和即將要執行的查詢式</p>
<pre><code class="language-csharp">class Program
{
    static void Main(string[] args)
    {
        ExecuteQuery(&quot;SELECT id,x,y FROM users;&quot;);
    }
    
    public static void ExecuteQuery(string sqlstr)
    {
        using (var pgconn = new NpgsqlConnection(connStr))
        {
            pgconn.Open();
            using (var cmd = new NpgsqlCommand(sqlstr, pgconn))
            {
                using (var reader = cmd.ExecuteReader())//使用NpgsqlDataReader讀取資料
                {
                    while (reader.Read())//讀取下一列直到沒有數值
                    {
                        Console.Write(reader.GetInt32(0));//0代表該列第0行的值，也就是對應到查詢式中的id
                        Console.Write(reader.GetDouble(1));//1代表該列第1行的值，也就是對應到查詢式中的x
                        Console.WriteLine(reader.GetDouble(2));//2代表該列第2行的值，也就是對應到查詢式中的y
                    }
                }
            }
        }
    }
    private static string host = &quot;localhost&quot;;
    private static string port = &quot;5432&quot;;
    private static string username = &quot;postgres&quot;;
    private static string password = &quot;password&quot;;
    private static string database = &quot;postgis&quot;;
    private static string connStr = $&quot;Host={host};Port={port};Username={username};Password={password};Database={database};&quot;;
}
</code></pre>
<h3 id="npgsqldataadapterdatatable">方法二：使用NpgsqlDataAdapter將資料放入DataTable</h3>
<pre><code class="language-csharp">class Program
{
    static void Main(string[] args)
    {
        DataTable dt = ExecuteQuery(&quot;SELECT id,x,y FROM sptable;&quot;);

        foreach (DataRow row in dt.Rows)
        {
            Console.WriteLine(&quot;{0} {1} {2}&quot;, row[0], row[1], row[2]);//輸出該行的0,1,2個值，分別為id,x,y的值
        }
    }
    public static DataTable ExecuteQuery(string sqlstr)
    {
        using (NpgsqlConnection pgconn = new NpgsqlConnection(connStr))
        {
            pgconn.Open();

            DataTable dt = new DataTable();//建立一個DataTable

            try
            {
                using (NpgsqlDataAdapter sqladap = new NpgsqlDataAdapter(sqlstr, pgconn))
                {
                    sqladap.Fill(dt);//使用NpgsqlDataAdapter將資料放入DataTable中
                }
                return dt;//返回DataTable
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.ToString());
                return dt;
            }
        }
    }
    private static string host = &quot;localhost&quot;;
    private static string port = &quot;5432&quot;;
    private static string username = &quot;postgres&quot;;
    private static string password = &quot;password&quot;;
    private static string database = &quot;postgis&quot;;
    private static string connStr = $&quot;Host={host};Port={port};Username={username};Password={password};Database={database};&quot;;
}
</code></pre>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[[Golang]使用筆畫排序中文字]]></title><description><![CDATA[有次嘗試要使用筆劃排序中文姓名時，直接使用sort包進行排序，但發現結果並不是照著筆劃排序，查了點資料發現原來和UTF-8、Big5兩種編碼有極大的關係]]></description><link>http://localhost:2368/golang-sort-traditionalchinese/</link><guid isPermaLink="false">5f4e5a4978355806f01eea76</guid><category><![CDATA[golang]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Tue, 01 Sep 2020 14:33:48 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/09/golang-long.jpeg" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><img src="http://localhost:2368/content/images/2020/09/golang-long.jpeg" alt="[Golang]使用筆畫排序中文字"><p>有次嘗試要使用筆劃排序中文姓名時，直接使用sort包進行排序，但發現結果並不是照著筆劃排序，查了點資料發現原來和UTF-8、Big5兩種編碼有極大的關係</p>
<h2 id>環境</h2>
<ul>
<li>Windows 10 x64</li>
<li>go 1.15</li>
<li>golang.org/x/text v0.3.3</li>
</ul>
<h2 id="utf8big5">UTF-8和Big5的排序</h2>
<h3 id="big5">Big5</h3>
<p>從全字庫查詢到Big5的編碼原則</p>
<blockquote>
<p>以國家標準CNS11643及國際標準ISO10646漢字集為字源範圍，並依CNS11643之序編碼。</p>
</blockquote>
<p>而CNS11643的字碼編排原則又是如何呢?以下是定義</p>
<blockquote>
<p>依<strong>先筆畫後部首</strong>排列順序編碼。 說明： 每一字面均以文字總筆畫數為首序、部首為次序、筆順為末序編訂字碼，使用者只需以書寫之實際筆畫數即可查尋到國標碼。</p>
</blockquote>
<p>所以我們可以得知Big5以&quot;<strong>筆畫-&gt;部首-&gt;筆順</strong>&quot;為排列順序</p>
<h3 id="utf8">UTF-8</h3>
<p>而全字庫裡對於UTF-8的說明如下</p>
<blockquote>
<p>在I區的中日韓漢字部份，最當初進行編碼時，因各國漢字型體不盡相同，必須先進行認同(unify)整理工作，SC2/WG2因此邀集有關各國指派專家組成CJK/JRG(中日韓聯合研究工作組，即IRG前身)，進行字集的總整理。CJK/JRG歷經五次會議完成此項艱鉅工作，所整理的「中日韓認同表意文字」(CJK Unified Ideographs)參考了我國75年版CNS 11643之第1、2、14字面(T欄)，大陸的GB 2312、GB 12345、GB 7589、GB 17590、GB 8565(G欄)，日本的JIS X 0208、JIS X 0212(J欄)及南韓的KS C 5601、KSC 5667(K欄)等標準字符集，可說已包含這四地所常用的字。其字序主要是參考康熙字典、大漢和詞典、漢語大詞典及大字源字典，以<strong>先部首後筆劃</strong>的順序排列。</p>
</blockquote>
<p>所以我們可以得知UTF-8以&quot;<strong>部首-&gt;筆畫</strong>&quot;為排列順序</p>
<h2 id="golang">Golang的預設編碼</h2>
<p>golang預設使用UTF-8作為編碼格式，所以若直接使用sort包進行排序得出的結果會是依照先部首後筆畫的順序排序</p>
<h2 id="big5">轉為Big5排序</h2>
<p>若想得到以先筆畫後部首的方式排序，其中一個方法是將預設的UTF-8轉為Big5，使用Big5排序過後依照需求再轉換回UTF-8</p>
<h2 id>程式碼</h2>
<p>以&quot;<strong>毛隆青,劉雅君,陳嘉鴻,王育如,郭苡良,楊宗穎,李玉全,劉玉合,姚昶民,林欣麟</strong>&quot;十個姓名作為測試資料輸入，結果應為[<strong>毛隆青 王育如 李玉全 林欣麟 姚昶民 郭苡良 陳嘉鴻 楊宗穎 劉玉合 劉雅君</strong>]</p>
<p>此處須注意若筆劃數量相同，則會比對完部首後再比對下一個字，例如:<br>
<strong>毛隆青</strong>和<strong>王育如</strong>姓氏都是四劃，但是比對過筆劃後結果是'<strong>毛</strong>'先於'<strong>王</strong>'所以'<strong>毛</strong>'才會排在'<strong>王</strong>'前面</p>
<p><strong>main.go</strong></p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;sort&quot;

	&quot;golang.org/x/text/encoding/traditionalchinese&quot;
	&quot;golang.org/x/text/transform&quot;
)

func main() {

	s := []string{&quot;毛隆青&quot;, &quot;劉雅君&quot;, &quot;陳嘉鴻&quot;, &quot;王育如&quot;, &quot;郭苡良&quot;, &quot;楊宗穎&quot;, &quot;李玉全&quot;, &quot;劉玉合&quot;, &quot;姚昶民&quot;, &quot;林欣麟&quot;}

	s1 := sortByStroke(s)
	fmt.Println(s1)
}

func sortByStroke(input []string) (output []string) {
	output = make([]string, 0)
    
	//建立Encoder和Decoder
	utf8ToBig5 := traditionalchinese.Big5.NewEncoder()
	big5ToUtf8 := traditionalchinese.Big5.NewDecoder()

	//將UTF-8轉換為Big5
	for index := range input {
		big5, _, _ := transform.String(utf8ToBig5, input[index])
		input[index] = big5
	}

	//使用轉換成Big5的編碼進行排序
	sort.Strings(input)

	//將排序過後的Big5碼轉回UTF-8並放入output slice
	for _, value := range input {
		utf8, _, _ := transform.String(big5ToUtf8, value)
		output = append(output, utf8)
	}

	return output
}
</code></pre>
<pre><code>D:\&gt;go run main
[毛隆青 王育如 李玉全 林欣麟 姚昶民 郭苡良 陳嘉鴻 楊宗穎 劉玉合 劉雅君]
</code></pre>
<h2 id>參考資料</h2>
<p><a href="https://www.cns11643.gov.tw/pageView.jsp?ID=9">全字庫-中文碼介紹</a></p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[[GolangPackage] 使用lnx/walk建立圖形化介面]]></title><description><![CDATA[golang 普遍使用CLI作為使用者介面，但因為需要做一個程式給不常使用指令的人使用，所以使用lxn/walk建立圖形化使用者介面，lxn/walk可以滿足視窗的大部分需求，適用於建立一些基本的圖形化介面]]></description><link>http://localhost:2368/golang-package-walk/</link><guid isPermaLink="false">5f4809f66c8c391358537596</guid><category><![CDATA[golang]]></category><category><![CDATA[golangPackage]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Thu, 27 Aug 2020 19:48:31 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/08/golang-long.jpeg" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><img src="http://localhost:2368/content/images/2020/08/golang-long.jpeg" alt="[GolangPackage] 使用lnx/walk建立圖形化介面"><p>golang 普遍使用CLI作為使用者介面，但因為需要做一個程式給不常使用指令的人使用，所以使用lxn/walk建立圖形化使用者介面，lxn/walk可以滿足視窗的大部分需求，適用於建立一些基本的圖形化介面</p>
<h2 id>環境</h2>
<ul>
<li>Windows 10 x64</li>
<li>go 1.15</li>
<li>github.com/lxn/walk v0.0.0-20200806153934-8721e9bc9ff7</li>
<li>github.com/akavel/rsrc v0.9.0</li>
</ul>
<h2 id>安裝</h2>
<p>要將程式包裝成可執行檔需要兩個package，分別是lxn/walk和akavel/rsrc<br>
lxn/walk用來建立圖形化介面<br>
akavel/rsrc用來將資源嵌入可執行檔<br>
使用指令安裝lxn/walk和akavel/rsrc</p>
<pre><code>go get github.com/lxn/walk
go get github.com/akavel/rsrc
</code></pre>
<h2 id>結構</h2>
<p>在lxn/walk下包含了declarative sub package、範例檔和各種元件的檔案</p>
<pre><code>－github.com
    |－lxn
        |－walk
            |－declarative
            |－examples
            |...其他檔案
</code></pre>
<p>以examples下的action範例裡的一小段程式碼為例</p>
<pre><code>PushButton{
	AssignTo: &amp;toggleSpecialModePB,
	Text:     &quot;Enable Special Mode&quot;,
	OnClicked: func() {
		isSpecialMode.SetSatisfied(!isSpecialMode.Satisfied())

		if isSpecialMode.Satisfied() {
			toggleSpecialModePB.SetText(&quot;Disable Special Mode&quot;)
		} else {
			toggleSpecialModePB.SetText(&quot;Enable Special Mode&quot;)
		}
	},
	Accessibility: Accessibility{
		Help: &quot;Toggles special mode&quot;,
	},
},
</code></pre>
<p>很好奇PushButton裡面的這些參數到底是哪裡來的對吧<br>
讓我們看看declarative目錄下的pushbutton.go檔案</p>
<p><strong>pushbutton.go</strong></p>
<pre><code>package declarative

import (
	&quot;github.com/lxn/walk&quot;
)

type PushButton struct {
	// Window

	Accessibility      Accessibility
	Background         Brush
	ContextMenuItems   []MenuItem
	DoubleBuffering    bool
	Enabled            Property
	Font               Font
	MaxSize            Size
	MinSize            Size
	Name               string
	OnBoundsChanged    walk.EventHandler
	OnKeyDown          walk.KeyEventHandler
	OnKeyPress         walk.KeyEventHandler
	OnKeyUp            walk.KeyEventHandler
	OnMouseDown        walk.MouseEventHandler
	OnMouseMove        walk.MouseEventHandler
	OnMouseUp          walk.MouseEventHandler
	OnSizeChanged      walk.EventHandler
	Persistent         bool
	RightToLeftReading bool
	ToolTipText        Property
	Visible            Property

	// Widget

	Alignment          Alignment2D
	AlwaysConsumeSpace bool
	Column             int
	ColumnSpan         int
	GraphicsEffects    []walk.WidgetGraphicsEffect
	Row                int
	RowSpan            int
	StretchFactor      int

	// Button

	Image     Property
	OnClicked walk.EventHandler
	Text      Property

	// PushButton

	AssignTo       **walk.PushButton
	ImageAboveText bool
}
</code></pre>
<p>這邊清楚的定義了哪些元件可以用哪些參數，只要照著結構裡定義的屬性名稱和型別給予對應的數值就可以了</p>
<h2 id>建置與執行</h2>
<p>要執行圖形化介面無法直接使用go run執行<br>
必須在相同目錄下新增.manifest檔案並使用go build建置產生可執行檔<br>
再啟動可執行檔執行<br>
我們使用examples下的clipboard作為範例</p>
<p><strong>clipboard.go</strong></p>
<pre><code>// Copyright 2013 The Walk Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	&quot;log&quot;
)

import (
	&quot;github.com/lxn/walk&quot;
	. &quot;github.com/lxn/walk/declarative&quot;
)

func main() {
	var te *walk.TextEdit

	if _, err := (MainWindow{
		Title:   &quot;Walk Clipboard Example&quot;,
		MinSize: Size{300, 200},
		Layout:  VBox{},
		Children: []Widget{
			PushButton{
				Text: &quot;Copy&quot;,
				OnClicked: func() {
					if err := walk.Clipboard().SetText(te.Text()); err != nil {
						log.Print(&quot;Copy: &quot;, err)
					}
				},
			},
			PushButton{
				Text: &quot;Paste&quot;,
				OnClicked: func() {
					if text, err := walk.Clipboard().Text(); err != nil {
						log.Print(&quot;Paste: &quot;, err)
					} else {
						te.SetText(text)
					}
				},
			},
			TextEdit{
				AssignTo: &amp;te,
			},
		},
	}).Run(); err != nil {
		log.Fatal(err)
	}
}
</code></pre>
<p><strong>test.manifest</strong></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
&lt;assembly xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot; manifestVersion=&quot;1.0&quot;&gt;
    &lt;assemblyIdentity version=&quot;1.0.0.0&quot; processorArchitecture=&quot;*&quot; name=&quot;SomeFunkyNameHere&quot; type=&quot;win32&quot;/&gt;
    &lt;dependency&gt;
        &lt;dependentAssembly&gt;
            &lt;assemblyIdentity type=&quot;win32&quot; name=&quot;Microsoft.Windows.Common-Controls&quot; version=&quot;6.0.0.0&quot; processorArchitecture=&quot;*&quot; publicKeyToken=&quot;6595b64144ccf1df&quot; language=&quot;*&quot;/&gt;
        &lt;/dependentAssembly&gt;
    &lt;/dependency&gt;
    &lt;application xmlns=&quot;urn:schemas-microsoft-com:asm.v3&quot;&gt;
        &lt;windowsSettings&gt;
            &lt;dpiAwareness xmlns=&quot;http://schemas.microsoft.com/SMI/2016/WindowsSettings&quot;&gt;PerMonitorV2, PerMonitor&lt;/dpiAwareness&gt;
            &lt;dpiAware xmlns=&quot;http://schemas.microsoft.com/SMI/2005/WindowsSettings&quot;&gt;True&lt;/dpiAware&gt;
        &lt;/windowsSettings&gt;
    &lt;/application&gt;
&lt;/assembly&gt;
</code></pre>
<p>建立一個目錄並在目錄底下放置clipboard.go和test.manifest兩個檔案</p>
<pre><code>－walktest
    |－clipboard.go
    |－test.manifest
</code></pre>
<p>第一次要使用指令產生.syso檔</p>
<pre><code>rsrc -manifest test.manifest -o rsrc.syso
</code></pre>
<p>再輸入指令建置可執行檔</p>
<pre><code>go build
</code></pre>
<p>運行可執行檔就會出現圖形化介面了</p>
<pre><code>walktest.exe
</code></pre>
<p><img src="http://localhost:2368/golang-package-walk/assets/1.png" alt="[GolangPackage] 使用lnx/walk建立圖形化介面"></p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[[Qt]Qt的鍵盤與滑鼠點擊事件]]></title><description><![CDATA[Qt的鍵盤與滑鼠點擊事件]]></description><link>http://localhost:2368/qt-key-mouse-press-event/</link><guid isPermaLink="false">5ee33b6118d9a726c4d13dcf</guid><category><![CDATA[Qt]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Fri, 12 Jun 2020 14:29:28 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/06/DarkCyan.jpg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2020/06/DarkCyan.jpg" alt="[Qt]Qt的鍵盤與滑鼠點擊事件"><p></p><h2 id="-">環境</h2><p>Qt 5.14.1<br>Qt Creator 4.11.1</p><hr><h2 id="--1">滑鼠點擊事件</h2><p>引用QMouseEvent標頭檔</p><!--kg-card-begin: markdown--><pre><code>#include &lt;QMouseEvent&gt;</code></pre>
<!--kg-card-end: markdown--><p>在protected裡定義滑鼠觸發事件</p><!--kg-card-begin: markdown--><pre><code>protected:
    void mousePressEvent(QMouseEvent * event);</code></pre>
<!--kg-card-end: markdown--><p>新增具體觸發事件</p><!--kg-card-begin: markdown--><pre><code>void MainWindow::mousePressEvent(QMouseEvent * e)
{
    //獲取座標
    qDebug() &lt;&lt;&quot;(&quot;&lt;&lt; e-&gt;x() &lt;&lt; &quot;,&quot; &lt;&lt; e-&gt;y()&lt;&lt;&quot;)&quot;;

    if(e-&gt;button() == Qt::LeftButton)
    {
        qDebug() &lt;&lt; &quot;左鍵&quot; ;
    }
    else if(e-&gt;button() == Qt::RightButton)
    {
        qDebug() &lt;&lt; &quot;右鍵&quot; ;
    }
}</code></pre>
<!--kg-card-end: markdown--><p>要使用qDebug()輸出時必須增加#include&lt;QDebug&gt;引用QDebug標頭檔</p><hr><h2 id="--2">鍵盤點擊事件</h2><p>在protected裡定義滑鼠觸發事件</p><!--kg-card-begin: markdown--><pre><code>protected:
    void keyPressEvent(QKeyEvent * event);</code></pre>
<!--kg-card-end: markdown--><p>新增鍵盤觸發事件</p><!--kg-card-begin: markdown--><pre><code>void MainWindow::keyPressEvent(QKeyEvent * event)
{
    switch (event-&gt;key())
    {
        case Qt::Key_Alt:{
                qDebug() &lt;&lt; &quot;Alt&quot;;
            break;
        }
        default:{
                qDebug() &lt;&lt; event-&gt;key();
            break;
        }
    }
}</code></pre>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[[GolangPackage]指定golang執行檔檔案屬性]]></title><description><![CDATA[GoVersionInfo package可在生成執行檔時指定執行檔縮圖及檔案屬性，檔案描述、檔案類型、版本等參數皆可指定]]></description><link>http://localhost:2368/golang-package-goversioninfo/</link><guid isPermaLink="false">5ec6a6b6986e6527cc1d24c9</guid><category><![CDATA[golangPackage]]></category><category><![CDATA[golang]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Thu, 21 May 2020 17:34:18 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/05/golang-long.jpeg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2020/05/golang-long.jpeg" alt="[GolangPackage]指定golang執行檔檔案屬性"><p>GoVersionInfo package可在生成執行檔時指定執行檔縮圖及檔案屬性，檔案描述、檔案類型、版本等參數皆可指定</p><hr><h2 id="-">安裝<br></h2><h3 id="-package">使用指令安裝package</h3><!--kg-card-begin: markdown--><pre><code>go get github.com/josephspurrier/goversioninfo/cmd/goversioninfo</code></pre>
<!--kg-card-end: markdown--><h3 id="--1">產生可執行檔</h3><p>-0 bin/goversioninfo.exe代表要將產生出來的可執行檔放在bin目錄裡，並將檔名命名為goversioninfo.exe<br>空一格後面接github.com/josephspurrier/goversioninfo/cmd/goversioninfo代表要以這個package為目標產生可執行檔</p><!--kg-card-begin: markdown--><pre><code>go build -o bin/goversioninfo.exe github.com/josephspurrier/goversioninfo/cmd/goversioninfo</code></pre>
<!--kg-card-end: markdown--><hr><h2 id="--2">設定<br></h2><h3 id="-go-generate-">設定go generate註釋</h3><p>將//go:generate goversioninfo加入到程式碼的最頂端，往後在執行go generate命令時才能夠被搜尋到</p><!--kg-card-begin: markdown--><pre><code>//go:generate goversioninfo

package main

import &quot;fmt&quot;

func main() {
    fmt.Println(&quot;Hello world&quot;)
}
</code></pre>
<!--kg-card-end: markdown--><h3 id="-versioninfo-json-">設定versioninfo.json檔案</h3><p>在github.com\josephspurrier\goversioninfo\testdata\resource內有一個檔名為versioninfo的json檔，將其複製並放置於要產生執行檔的程式碼的目錄中</p><p>resource資料夾內有icon和goversioninfo.exe.manifest兩個檔案，等等在設定versioninfo時會用到</p><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2020/05/---2020-05-22-012503.png" class="kg-image" alt="[GolangPackage]指定golang執行檔檔案屬性"></figure><h3 id="-versioninfo-json--1">指定versioninfo.json檔案參數</h3><p>將IconPath和ManifestPath的路徑指定為可執行檔圖示的路徑和Manifest檔案的路徑</p><!--kg-card-begin: markdown--><pre><code>{
    &quot;FixedFileInfo&quot;: {
        &quot;FileVersion&quot;: {
            &quot;Major&quot;: 1,
            &quot;Minor&quot;: 0,
            &quot;Patch&quot;: 0,
            &quot;Build&quot;: 0
        },
        &quot;ProductVersion&quot;: {
            &quot;Major&quot;: 1,
            &quot;Minor&quot;: 0,
            &quot;Patch&quot;: 0,
            &quot;Build&quot;: 0
        },
        &quot;FileFlagsMask&quot;: &quot;3f&quot;,
        &quot;FileFlags &quot;: &quot;00&quot;,
        &quot;FileOS&quot;: &quot;040004&quot;,
        &quot;FileType&quot;: &quot;01&quot;,
        &quot;FileSubType&quot;: &quot;00&quot;
    },
    &quot;StringFileInfo&quot;: {
        &quot;Comments&quot;: &quot;Test file.&quot;,
        &quot;CompanyName&quot;: &quot;josephspurrier&quot;,
        &quot;FileDescription&quot;: &quot;This is a hello world file.&quot;,
        &quot;FileVersion&quot;: &quot;v1.0.0.0&quot;,
        &quot;InternalName&quot;: &quot;goversioninfo.exe&quot;,
        &quot;LegalCopyright&quot;: &quot;Copyright (c) 2019 Joseph Spurrier&quot;,
        &quot;LegalTrademarks&quot;: &quot;&quot;,
        &quot;OriginalFilename&quot;: &quot;main.go&quot;,
        &quot;PrivateBuild&quot;: &quot;&quot;,
        &quot;ProductName&quot;: &quot;goversioninfo&quot;,
        &quot;ProductVersion&quot;: &quot;v1.0.0.0&quot;,
        &quot;SpecialBuild&quot;: &quot;&quot;
    },
    &quot;VarFileInfo&quot;: {
        &quot;Translation&quot;: {
            &quot;LangID&quot;: &quot;0409&quot;,
            &quot;CharsetID&quot;: &quot;04B0&quot;
        }
    },
    &quot;IconPath&quot;: &quot;resource/icon.ico&quot;,
    &quot;ManifestPath&quot;: &quot;resource/goversioninfo.exe.manifest&quot;
}</code></pre>
<!--kg-card-end: markdown--><h3 id="-syso-">產生syso檔</h3><p>輸入go generate指令產生resource.syso檔案，若不在同個目錄內可指定package路徑，例如主程式在D:\Project\Go\src\goinfotest，若當前位置在目錄內直接下go generate即可，若不在目錄內則要輸入go generate+從src目錄後開始算的package路徑(go generate goinfotest)產生syso檔</p><!--kg-card-begin: markdown--><pre><code>go generate
go generate your\package\route</code></pre>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2020/05/---2020-05-22-013035.png" class="kg-image" alt="[GolangPackage]指定golang執行檔檔案屬性"></figure><h3 id="--3">產生可執行檔</h3><p>使用go build產生可執行檔，亦可使用"go build -o 目的路徑與檔名 +package路徑"產生可執行檔</p><!--kg-card-begin: markdown--><pre><code>go build
go build -o output\route your\package\route</code></pre>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2020/05/---2020-05-22-013343.png" class="kg-image" alt="[GolangPackage]指定golang執行檔檔案屬性"></figure>]]></content:encoded></item><item><title><![CDATA[[C++]陣列與指標的位址]]></title><description><![CDATA[C++陣列與指標的位址]]></description><link>http://localhost:2368/cpp-array-pointer-address/</link><guid isPermaLink="false">5e71c4046286de0ce0c06f09</guid><category><![CDATA[C++]]></category><category><![CDATA[C++Basic]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Wed, 18 Mar 2020 07:43:05 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/03/C--.jpg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2020/03/C--.jpg" alt="[C++]陣列與指標的位址"><p>首先宣告名稱為arr大小為10的int陣列，接著分別輸出arr、&amp;arr[0]和&amp;arr</p><!--kg-card-begin: markdown--><pre><code>#include &lt;iostream&gt;

int main()
{
    int arr[10] = { 0 };

    std::cout &lt;&lt; &quot;arr\t&quot; &lt;&lt; arr &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;&amp;arr[0]\t&quot; &lt;&lt; &amp;arr[0] &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;&amp;arr\t&quot; &lt;&lt; &amp;arr &lt;&lt; std::endl;
}</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>&gt;arr     006FFC80
&gt;&amp;arr[0] 006FFC80
&gt;&amp;arr    006FFC80</code></pre>
<!--kg-card-end: markdown--><p>我們可以看到直接輸出陣列變數時會出現陣列中第一個元素的位址</p><p>輸出&amp;arr[0]也會出現陣列中第一個元素的位址，其中arr[0]代表第零個元素，而將&amp;加在前面則代表取得其位址，也就是arr[0]的位址</p><p>2而&amp;arr代表輸出arr變數位址，其位址就是第零個元素的位址，也就等於arr[0]的位址，所以輸出的結果會與前兩個相同</p><p></p><p>這時我們宣告一個名稱為p的int指標，將arr的位址指派給它，並分別輸出p、&amp;p[0]和&amp;p</p><!--kg-card-begin: markdown--><pre><code>#include &lt;iostream&gt;

int main()
{
    int arr[10] = { 0 };

    std::cout &lt;&lt; &quot;arr\t&quot; &lt;&lt; arr &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;&amp;arr[0]\t&quot; &lt;&lt; &amp;arr[0] &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;&amp;arr\t&quot; &lt;&lt; &amp;arr &lt;&lt; std::endl;

    int* p = arr;
    std::cout &lt;&lt; &quot;p\t&quot; &lt;&lt; p &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;&amp;p[0]\t&quot; &lt;&lt; &amp;p[0] &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;&amp;p\t&quot; &lt;&lt; &amp;p &lt;&lt; std::endl;
}</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>&gt;p       006FFC80
&gt;&amp;p[0]   006FFC80
&gt;&amp;p      006FFC74</code></pre>
<!--kg-card-end: markdown--><p>這時p指標中儲存的是arr的位址，所以輸出的自然也就和arr的位址相同</p><p>&amp;p[0]指的是p[0]這個元素的位址，因為p指標是指向arr陣列的，所以當存取p[0]時會去尋找arr[0]，而自然其位址也就會等於arr[0]的位址</p><p>比較特別的是&amp;p，&amp;p代表取得p的位址，而因為p是指標，我們是取得p的位址，所以和arr的位址就不會是同一個了</p>]]></content:encoded></item><item><title><![CDATA[[Clover]開啟Clover時顯示錯誤訊息：Cannot install without ensuring the file system is read-write]]></title><description><![CDATA[在開啟Clover時會跳出"Cannot install without ensuring the file system is read-write"錯誤訊息]]></description><link>http://localhost:2368/clover-package-err/</link><guid isPermaLink="false">5e512e2257c9b119c4cb7261</guid><category><![CDATA[clover]]></category><category><![CDATA[hackintosh]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Sat, 22 Feb 2020 14:11:49 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/02/clover-1.png" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2020/02/errMsg.png" class="kg-image" alt="[Clover]開啟Clover時顯示錯誤訊息：Cannot install without ensuring the file system is read-write"></figure><img src="http://localhost:2368/content/images/2020/02/clover-1.png" alt="[Clover]開啟Clover時顯示錯誤訊息：Cannot install without ensuring the file system is read-write"><p></p><h2 id="-">版本</h2><p>OS：macOs Catalina  Version 10.15.3<br>Clover：Clover_v2.5k_r5104</p><hr><h2 id="--1">問題</h2><p>在開啟Clover時會跳出"Cannot install without ensuring the file system is read-write"錯誤訊息</p><hr><h2 id="--2">解決方法及步驟</h2><p>1.Click the Apple symbol in the Menu bar.<br>2.Click Restart…<br>3.Hold down Command-R to reboot into Recovery Mode.<br>4.Click Utilities.<br>5.Select Terminal.<br>6.Type csrutil disable.<br>7.Press Return or Enter on your keyboard.<br>8.Click the Apple symbol in the Menu bar.<br>9.Click Restart…</p><hr><h2 id="--3">參考資料</h2><figure class="kg-card kg-embed-card">
    <blockquote class="reddit-card">
      <a href="https://www.reddit.com/r/hackintosh/comments/d9pbhy/clover_cannot_install_wo_ensuring_file_system_is/?ref_source=embed&amp;ref=share">Clover - Cannot Install w/o Ensuring File System is Read/Write</a> from
      <a href="https://www.reddit.com/r/hackintosh/">hackintosh</a>
    </blockquote>
    <script async src="https://embed.redditmedia.com/widgets/platform.js" charset="UTF-8"></script>
</figure>]]></content:encoded></item><item><title><![CDATA[[Golang]channel簡介]]></title><description><![CDATA[在golang裡可使用channel在多個執行緒與主程式之間傳送資料，channel可設定不同型態的buffer，並指定緩衝區大小]]></description><link>http://localhost:2368/golang-channel/</link><guid isPermaLink="false">5e2ee3d2c847230f10934c35</guid><category><![CDATA[golang]]></category><category><![CDATA[golangBasic]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Mon, 27 Jan 2020 15:43:32 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/01/golang-long-2.jpeg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2020/01/golang-long-2.jpeg" alt="[Golang]channel簡介"><p></p><p>在golang裡可使用channel在多個執行緒與主程式之間傳送資料，channel可設定不同型態的buffer，並指定緩衝區大小</p><hr><h2 id="-channel">建立channel</h2><p>使用make配置空間，第一個參數使用chan指定為通道類型，後面接上channel的型態，第二個參數可加可不加，用來宣告buffer的大小</p><!--kg-card-begin: markdown--><pre><code>ch := make(chan int)
ch := make(chan int,5)</code></pre>
<!--kg-card-end: markdown--><p>須注意buffer的預設大小為零，若無指定buffer大小則發送方與接收方需同時準備好才可傳值，否則會造成deadlock(死結)</p><!--kg-card-begin: markdown--><pre><code>//OK(buffer為0)
ch := make(chan int)
defer close(ch)
go func(){
    ch &lt;- 7
}()

fmt.Println(&lt;-ch)

//ERROR(buffer為0)
ch := make(chan int)
defer close(ch)
ch &lt;- 7

fmt.Println(&lt;-ch)

//OK(buffer為1)
ch := make(chan int,1)
defer close(ch)
ch &lt;- 7

fmt.Println(&lt;-ch)</code></pre>
<!--kg-card-end: markdown--><hr><h2 id="-channel-">使用channel傳遞數值</h2><h3 id="-channel-1">傳入channel</h3><p>將箭頭由數值指向channel，代表將值傳入到channel內</p><!--kg-card-begin: markdown--><pre><code>ch &lt;- 7</code></pre>
<!--kg-card-end: markdown--><h3 id="-channel-2">傳出channel</h3><p>將箭頭由channel指向目的地，代表將數值由channel傳出</p><!--kg-card-begin: markdown--><pre><code>var result int
result &lt;- ch
fmt.Println(result)</code></pre>
<!--kg-card-end: markdown--><hr><h2 id="-goroutine-">等待所有goroutine結束</h2><p>有時會遇到明明寫好了goroutine，但在最後將要把數據輸出時卻沒出現任何數據，這時就有可能是因為執行緒尚未結束運算而主程式已經執行完輸出的作業了，所以輸出時不會得到channel傳來的任何資訊，當然也不會輸出任何東西</p><!--kg-card-begin: markdown--><pre><code>func foo(ch chan int, val int) {
    ch &lt;- val
}

func main() {
    ch := make(chan int, 5)
    for i := 0; i &lt; 5; i++ {
        foo(ch, i)
    }
    close(ch)

    for ele := range ch {
        fmt.Println(ele)
    }
}</code></pre>
<!--kg-card-end: markdown--><p>我們可以使用WaitGroup控制，等到所有執行緒都結束後再繼續往下執行</p><!--kg-card-begin: markdown--><pre><code>var wg sync.WaitGroup

func foo(ch chan int, val int) {
    defer wg.Done()
    ch &lt;- val
}

func main() {
    ch := make(chan int, 5)
    for i := 0; i &lt; 5; i++ {
        wg.Add(1)
        foo(ch, i)
    }
    wg.Wait()
    close(ch)

    for ele := range ch {
        fmt.Println(ele)
    }
}</code></pre>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[[GolangPackage]Excel的讀寫與操作]]></title><description><![CDATA[excelize是一個能夠讀寫excel的package，可讀入或寫入指定位置的資料及更改樣式，適用於批量產生excel檔案及資料處理]]></description><link>http://localhost:2368/golang-package-excelize/</link><guid isPermaLink="false">5e2d660c17169e27181beddf</guid><category><![CDATA[golang]]></category><category><![CDATA[golangPackage]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Sun, 26 Jan 2020 15:50:18 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/01/golang-long-1.jpeg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2020/01/golang-long-1.jpeg" alt="[GolangPackage]Excel的讀寫與操作"><p></p><p>excelize是一個能夠讀寫excel的package，可讀入或寫入指定位置的資料及更改樣式，適用於批量產生excel檔案及資料處理，須注意的是該package只支援.xlsx的檔案格式，尚不支援.xls的檔案處理</p><hr><h2 id="-">安裝</h2><p>使用指令安裝package</p><!--kg-card-begin: markdown--><pre><code>go get github.com/Luxurioust/excelize</code></pre>
<!--kg-card-end: markdown--><hr><h2 id="--1">檔案操作<br></h2><h3 id="--2">創建新檔</h3><!--kg-card-begin: markdown--><pre><code>xlsx := excelize.NewFile()</code></pre>
<!--kg-card-end: markdown--><h3 id="--3">開啟舊檔</h3><!--kg-card-begin: markdown--><pre><code>inputFilePath := &quot;D:\Project&quot;
xlsx, err := excelize.OpenFile(inputFilePath)
if err != nil {
	fmt.Println(&quot;\rERROR:&quot;, err)
}</code></pre>
<!--kg-card-end: markdown--><h3 id="--4">讀取內容</h3><p>將檔案內的資料讀入一個二維的字串slice</p><!--kg-card-begin: markdown--><pre><code>sheetName := &quot;Sheet1&quot;//指定要讀取的工作表名稱
xlsxRows, err = xlsx.GetRows(sheetName)
if err != nil {
	fmt.Println(&quot;\rERROR:&quot;,err)
}</code></pre>
<!--kg-card-end: markdown--><h3 id="--5">變更工作表名稱</h3><!--kg-card-begin: markdown--><pre><code>oldSheetName := &quot;Sheet1&quot;//指定目前工作表名稱
newSheetName := &quot;工作表&quot;//指定新的工作表名稱
xlsx.SetSheetName(oldSheetName, newSheetName)</code></pre>
<!--kg-card-end: markdown--><h3 id="--6">設定樣式</h3><p><strong>建立樣式</strong><br>呼叫函式時使用JSON格式填入所需的樣式參數</p><p>fill：設定儲存格網底</p><!--kg-card-begin: markdown--><table>
<thead>
<tr>
<th>fill</th>
<th>使用單一顏色填充</th>
<th>使用漸層填充</th>
</tr>
</thead>
<tbody>
<tr>
<td>typr</td>
<td>pattern</td>
<td>gradient</td>
</tr>
<tr>
<td>color</td>
<td>[&quot;#FFFFFF&quot;]</td>
<td>[&quot;#FFFFFF&quot;,&quot;#E0EBF5&quot;]</td>
</tr>
<tr>
<td>gradient</td>
<td>X</td>
<td>0:橫向<br>1:縱向<br>2:對角線向上<br>3:對角線向下<br>4:由對角線向內<br>5:由中心向外</td>
</tr>
<tr>
<td>pattern</td>
<td>0:無<br>1:實心<br>2:75%灰色<br>3:50%灰色<br>4:25%灰色<br>5:水平條紋<br>6:垂直條紋<br>7:反對角線條紋<br>8:對角線條紋<br>9:對角線斜紋<br>10:粗線對角線斜紋<br>11:細線水平條紋<br>12:細線垂直條紋<br>13:細線反對角線條紋<br>14:細線對角線條紋<br>15:細線水平斜紋<br>16:細線對角線斜紋<br>17:12.5%灰色<br>18:6.25%灰色</td>
<td>X</td>
</tr>
</tbody>
</table>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>//單一顏色填充
patternStyle, err := xlsx.NewStyle(`{&quot;fill&quot;:{&quot;type&quot;:&quot;pattern&quot;,&quot;color&quot;:[&quot;#EBF0F3&quot;],&quot;pattern&quot;:1}}`)
if err != nil {
	fmt.Println(&quot;\rERROR:&quot;,err)
}

//漸層填充
gradientStyle, err := f.NewStyle(`{&quot;fill&quot;:{&quot;type&quot;:&quot;gradient&quot;,&quot;color&quot;:[&quot;#FFFFFF&quot;,&quot;#E0EBF5&quot;],&quot;shading&quot;:1}}`)
if err != nil {
    fmt.Println(err)
}
</code></pre>
<!--kg-card-end: markdown--><p></p><p>font：設定儲存格字體</p><!--kg-card-begin: markdown--><table>
<thead>
<tr>
<th style="text-align:center">font</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">bold</td>
<td style="text-align:center">true/false</td>
</tr>
<tr>
<td style="text-align:center">italic</td>
<td style="text-align:center">true/false</td>
</tr>
<tr>
<td style="text-align:center">family</td>
<td style="text-align:center">字型名稱</td>
</tr>
<tr>
<td style="text-align:center">size</td>
<td style="text-align:center">字體大小</td>
</tr>
<tr>
<td style="text-align:center">color</td>
<td style="text-align:center">[&quot;#FFFFFF&quot;]</td>
</tr>
</tbody>
</table>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>fontStyle, err := f.NewStyle(`{&quot;font&quot;:{&quot;bold&quot;:true,&quot;italic&quot;:false,&quot;size&quot;:12,&quot;color&quot;:&quot;#FFFFFF&quot;}}`)
if err != nil {
    fmt.Println(err)
}</code></pre>
<!--kg-card-end: markdown--><p><strong>使用樣式</strong></p><!--kg-card-begin: markdown--><pre><code>//使用樣式設定column
err := xlsx.SetColStyle(sheetName, &quot;A1&quot;, patternStyle)

//使用樣式設定cell
err := xlsx.SetCellStyle(sheetName, &quot;A1&quot;, &quot;A1&quot;, gradientStyle)</code></pre>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[記憶體的時脈與頻寬]]></title><description><![CDATA[記憶體的時脈與頻寬]]></description><link>http://localhost:2368/clock-and-bandwidth/</link><guid isPermaLink="false">5e1de4127108022a40ad7b02</guid><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Tue, 14 Jan 2020 16:21:42 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/01/binary-code-binary-binary-system-byte-bits-administrator-1458897-pxhere.com.jpg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2020/01/binary-code-binary-binary-system-byte-bits-administrator-1458897-pxhere.com.jpg" alt="記憶體的時脈與頻寬"><p></p><h2 id="-">傳輸寬度</h2><h3 id="--1">每次可傳輸的量</h3><p>資料進出記憶體時會有寬度的限制，若頻寬是8bit，則代表一次可進去8個bit，若是64bit，則代表一次可同時傳輸64bit</p><hr><h2 id="--2">時脈</h2><h3 id="--3">一秒可傳輸多少次</h3><p>以Hz作為單位，代表一秒可以傳多少次，例如800MHz則為每秒800百萬次</p><hr><h2 id="--4">頻寬</h2><h3 id="--5">一秒可傳輸的量</h3><p>一秒可傳輸多少次 * 每次可傳輸的量 = 一秒可傳輸的量，以寬度為64bit及時脈為800HHz的例子來說，記憶體頻寬即為每秒64GB</p><p>64bit * 800MHz = 8Bytes * 800MHz = 6400 MBHz = 6.4GBHz = 每秒64GB</p>]]></content:encoded></item><item><title><![CDATA[[Python]使用Python爬蟲抓取網站資料]]></title><description><![CDATA[使用python抓取網站或網頁資料是再方便不過的了，常見的抓取方法包含抓取網站回應的JSON檔，或是直接抓取網頁內容並進行分析，以下紀錄兩種方法該如何實作。]]></description><link>http://localhost:2368/python-web-crawler/</link><guid isPermaLink="false">5e0e8ba22418ef16205128e7</guid><category><![CDATA[python]]></category><category><![CDATA[crawler]]></category><dc:creator><![CDATA[Katsuobushi]]></dc:creator><pubDate>Fri, 03 Jan 2020 16:48:36 GMT</pubDate><media:content url="http://localhost:2368/content/images/2020/01/python-logo.jpg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2020/01/python-logo.jpg" alt="[Python]使用Python爬蟲抓取網站資料"><p></p><p>使用python抓取網站或網頁資料是再方便不過的了，常見的抓取方法包含抓取網站回應的JSON檔，或是直接抓取網頁內容並進行分析，以下紀錄兩種方法該如何實作。</p><hr><h2 id="-">建立請求<br></h2><p>載入requests模組以建立HTTP請求</p><!--kg-card-begin: markdown--><pre><code>import requests</code></pre>
<!--kg-card-end: markdown--><p>建立GET請求</p><!--kg-card-begin: markdown--><pre><code>url = '' //填入目標網址以取得網頁內容
resp = requests.get(url) //建立get請求</code></pre>
<!--kg-card-end: markdown--><hr><h2 id="--1">解析請求<br></h2><h3 id="-json">目標為JSON</h3><p>使用<strong>json()</strong>方法解析內容，返回值(data)為字典</p><!--kg-card-begin: markdown--><pre><code>data = resp.json()</code></pre>
<!--kg-card-end: markdown--><h3 id="-html-">目標為HTML網頁內容</h3><p>需使用BeautifulSoup模組裡的方法，使用以下指令載入該模組</p><!--kg-card-begin: markdown--><pre><code>from bs4 import BeautifulSoup</code></pre>
<!--kg-card-end: markdown--><p>使用<strong>BeautifulSoup(htmlMarkup,'html5lib')</strong>方法解析網頁內容，返回值(soup)為&lt;class 'bs4.BeautifulSoup'&gt;</p><!--kg-card-begin: markdown--><pre><code>soup = BeautifulSoup(resp.text,'html5lib')</code></pre>
<!--kg-card-end: markdown--><hr><h2 id="--2">取得內容<br></h2><h3 id="-json-1">目標為JSON</h3><p>以台灣證券交易所-201901月個股日成交資訊為例，網址為'<a href="https://www.twse.com.tw/exchangeReport/STOCK_DAY?response=json&amp;date=20190101&amp;stockNo=2881">https://www.twse.com.tw/exchangeReport/STOCK_DAY?response=json&amp;date=20190101&amp;stockNo=2881</a>'，該請求返回的內容如下圖</p><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2020/01/bandicam-2020-01-03-22-28-14-255.jpg" class="kg-image" alt="[Python]使用Python爬蟲抓取網站資料"></figure><p>需使用Pandas模組裡的方法，使用以下指令載入該模組</p><!--kg-card-begin: markdown--><pre><code>import pandas as pd
</code></pre>
<!--kg-card-end: markdown--><p>我們需要取得data裡的0~20所有資訊做為內容，將其放入pandas的dataframe裡，並使用fields作為其欄位的標籤</p><!--kg-card-begin: markdown--><pre><code>//data[]為先前取得的資料，型態為字典
df = pd.DataFrame(data['data'],columns = data['fields'])</code></pre>
<!--kg-card-end: markdown--><p>若要使用foreach迴圈讀取或印出dataframe的內容時，需使用<strong>df.values</strong>作為範圍，若只使用df作為範圍會得到錯誤的結果</p><!--kg-card-begin: markdown--><pre><code>for row in df:
    print(row)
</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>&gt;日期
成交股數
成交金額
開盤價
最高價
最低價
收盤價
漲跌價差
成交筆數</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>for row in df.values:
    print(row)</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>&gt;['108/10/01' '8,895,183' '399,156,974' '44.85' '45.00' '44.75' '45.00' '+0.45' '3,310']
['108/10/02' '4,399,985' '196,735,002' '44.55' '44.85' '44.55' '44.75' '-0.25' '1,745']
...
['108/10/31' '17,527,040' '787,119,996' '45.40' '45.40' '44.55' '44.55' '-0.90' '5,017']</code></pre>
<!--kg-card-end: markdown--><h3 id="-html--1">目標為HTML網頁內容</h3><p>類別為'bs4.BeautifulSoup'的物件可使用以下方法<br><br>find()	//查詢第一筆符合的資料<br>find(htmlTag)	//查詢標籤類型為htmlTag的第一筆元素<br>find(id='elementID')	//查詢id為elementID的元素<br>find(htmlTag,class_='className')	//查詢標籤為htmlTag且class為className的第一筆元素<br>find(htmlTag,className)	//查詢標籤為htmlTag且class為className的第一筆元素<br><br>find_all()	//查詢所有符合的元素<br>find_all(htmlTag)	//查詢所有符合標籤類型為htmlTag的元素<br>find_all(id='elementID')	//查詢id為elementID的元素<br>find_all(htmlTag,class_='className')	//查詢標籤為htmlTag且class為className的所有元素<br>find_all(htmlTag,className)	//查詢標籤為htmlTag且class為className的所有元素</p><p>若使用find_all()查詢，可使用foreach迴圈歷遍所有查找到的元素</p><!--kg-card-begin: markdown--><pre><code>for content in soup.find_all('li'):
    print(content.string)</code></pre>
<!--kg-card-end: markdown--><p>使用<strong>.string</strong>方法取得元素的內容</p><!--kg-card-begin: markdown--><pre><code>soup = BeautifulSoup('&lt;h1 id=&quot;thisish1&quot;&gt;content&lt;/h1&gt;', 'html5lib')
print(soup.h1)</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>&gt;&lt;h1 id=&quot;thisish1&quot;&gt;content&lt;/h1&gt;</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>soup = BeautifulSoup('&lt;h1 id=&quot;thisish1&quot;&gt;content&lt;/h1&gt;', 'html5lib')
print(soup.h1.string)</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>&gt;content</code></pre>
<!--kg-card-end: markdown--><p>使用get('href')方法取得元素的href屬性</p><!--kg-card-begin: markdown--><pre><code>soup = BeautifulSoup('&lt;h1 href=&quot;katsuobushi.com&quot;&gt;content&lt;/h1&gt;', 'html5lib')
print(soup.h1.get('href'))</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>&gt;katsuobushi.com</code></pre>
<!--kg-card-end: markdown--><hr><h2 id="--3">輸出為檔案<br></h2><h3 id="-csv-">輸出為csv檔案</h3><p>需載入os及csv模組以使用open及writer方法</p><!--kg-card-begin: markdown--><pre><code>import os
import csv</code></pre>
<!--kg-card-end: markdown--><p>使用w模式開啟檔案，w模式為打開一個文件只用於寫入，若文件已存在則打开文件，並從頭開始編輯，原有内容會被刪除。若文件不存在，則創建新文件。</p><!--kg-card-begin: markdown--><pre><code>file = open(filepath,'w',newline='',encoding='utf-8-sig')</code></pre>
<!--kg-card-end: markdown--><p>使用csv.writer()創建一個writer</p><!--kg-card-begin: markdown--><pre><code>csvWriter = csv.writer(file)</code></pre>
<!--kg-card-end: markdown--><p>writerow()方法可將一列資料寫入到檔案中</p><!--kg-card-begin: markdown--><pre><code>csvWriter.writerow(row)</code></pre>
<!--kg-card-end: markdown--><p>寫入完畢後須關閉檔案，釋放資源</p><!--kg-card-begin: markdown--><pre><code>file.close()</code></pre>
<!--kg-card-end: markdown-->]]></content:encoded></item></channel></rss>